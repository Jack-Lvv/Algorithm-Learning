# 存储引擎

![MySQL2-1](C:\Users\25798\OneDrive\Notes\image\MySQL2-1.png)

1). **连接层** 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于  TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。 

2). **服务层** 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，  最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。 

3). **引擎层** 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。 默认为InnoDB。

4). **存储层** 数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。 

和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，**插件式的存储引擎架构**，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

**存储引擎**就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为**表类型**。

1、建表时指定存储引擎，默认存储引擎: InnoDB

```mysql
CREATE TABLE  表名(
	字段1  字段1类型   [COMMENT  字段1注释] ,
 	......
	字段n  字段n类型   [COMMENT  字段n注释] 
) ENGINE = INNODB   [COMMENT  表注释] ;
```

2、查询当前数据库支持的存储引擎

```mysql
show engines;
```

## InnoDB

InnoDB是一种**兼顾高可靠性和高性能**的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的  MySQL 存储引擎。

1、DML操作遵循ACID模型，支持事务

2、行级锁，提高并发访问性能

3、支持外键FOREIGN KEY约束，保证数据的完整性和正确性

表名.ibd：innoDB引擎的每张表都会对应这样一个**表空间文件**，存储该表的**表结构**（frm-早期的 、sdi-新版的）、**数据和索引**。该文件是基于**二进制存储**的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息

innodb_file_per_table该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。

查看参数：

```mysql
show variables  like 'innodb_file_per_table';
```

![MySQL2-2](C:\Users\25798\OneDrive\Notes\image\MySQL2-2.jpg)

1、表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。
2、段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
3、区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。
4、页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默
认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
5、行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段。

## MyISAM

MyISAM是MySQL早期的默认存储引擎。

1、不支持事务，不支持外键
2、支持表锁，不支持行锁
3、访问速度快

文件包括：
1、xxx.sdi：存储表结构信息
2、xxx.MYD: 存储数据
3、xxx.MYI: 存储索引

## Memory

Memory引擎的表数据时存储在**内存**中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为**临时表或缓存**使用。

1、内存存放
2、hash索引（默认）

文件包括：
xxx.sdi：存储表结构信息

## 总结

![MySQL2-3](C:\Users\25798\OneDrive\Notes\image\MySQL2-3.png)

InnoDB引擎与MyISAM引擎的区别 ?
①. InnoDB引擎, 支持事务, 而MyISAM不支持。
②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。
③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。

适用场景：

**InnoDB**: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求**数据的一致性**，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
**MyISAM** ： 如果应用是**以读操作和插入操作为主**，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
**MEMORY**：将所有数据保存在**内存**中，访问速度快，通常用于**临时表及缓存**。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且**无法保障数据的安全性**。

# 索引

**索引**（index）是帮助MySQL高效获取数据的**数据结构**(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-4.png)

MySQL的索引是在**存储引擎层**实现的，不同的存储引擎有不同的索引结构，默认为**B+Tree**

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-5.png)

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-6.png)

## B+Tree

1、所有的数据都会出现在叶子节点。
2、叶子节点形成一个单向链表。
3、非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-7.png)

## Hash

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

1、Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
2、无法利用索引完成排序操作
3、查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引

在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。

为什么InnoDB存储引擎选择使用B+tree索引结构?
1、相对于二叉树，层级更少，搜索效率高；
2、对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
3、相对Hash索引，B+tree支持范围匹配及排序操作；

## 索引分类

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-8.png)

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-9.png)

聚集索引选取规则:
1、如果存在主键，主键索引就是聚集索引。
2、如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
3、如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索
引。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-10.jpg)

1、**聚集索引**的叶子节点下挂的是**这一行的数据** 。
2、**二级索引**的叶子节点下挂的是该字段值对应的**主键值**。

**回表查询**： 先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。

**主键查询语句的执行性能要高**于其他字段查询语句。
因为主键查询语句**直接走聚集索引**，直接返回数据。 而其他字段查询语句需要先查询字段的二级索引，然后再查询聚集索引，也就是**需要进行回表查询**。

## 索引语法

创建索引

```mysql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (
index_col_name,... ) ;
-- 可以多个字段建立联合索引
```

查看索引

```mysql
SHOW INDEX 1 FROM table_name ;
```

删除索引

```mysql
DROP INDEX index_name ON table_name ;
```

## 索引使用

### 最左前缀法则

如果**索引了多列（联合索引）**，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。没有最左边的列，将不使用这个索引。**跟查询语句中位置无关，只与是否存在有关。**

联合索引中，出现**范围查询**(>,<)，范围查询**右侧的列索引失效**。业务允许的情况下尽量替换成**>=，<=**，不会引起索引失效。

### 索引失效情况

在索引列上进行**运算操作**， 索引将失效。

**字符串类型字段**使用时，**不加引号**，索引将失效。字符串不加单引号，对于查询结果，没什么影响，但是数据库**存在隐式类型转换**，索引将失效。

尾部**模糊匹配**，索引不会失效。如果是**头部模糊匹配，索引失效**。

当**or连接**的条件，**左右两侧字段都有索引**时，索引才会生效。

如果**MySQL评估**使用**索引比全表更慢**，则不使用索引。索引是用来索引少量数据的，如果通过索引查询**返回大批量的数据**，则还不如走全表扫描来的快，此时索引就会失效。

## SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些**人为的提示**来达到优化操作的目的。

use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进
行评估）。

```mysql
select * from tb_user use index(idx_user_pro) where profession = '软件工
程';
```

ignore index ： 忽略指定的索引。

```mysql
explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';
```

force index ： 强制使用索引。

```mysql
explain select * from tb_user force index(idx_user_pro) where profession = '软件工程';
```

## 覆盖索引

尽量使用覆盖索引，减少**select ***。

覆盖索引是指查询使用了索引，并且需要返回的列，**在该索引中已经全部能够找到** ,不需要回表查询。

## 前缀索引

当字段类型为**字符串**（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将**字符串的一部分前缀，建立索引**，这样可以**大大节约索引空间**，从而提高索引效率。

```mysql
create index idx_xxxx on table_1 name(字段名(n)) ;
-- n表示字段的前缀索引长度
```

**前缀索引长度**可以根据**索引的选择性**来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，**索引选择性越高则查询效率越高**， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

遇到相同前缀需要通过链表查询相近节点。

## 单列索引与联合索引

在业务场景中，如果存在**多个查询条件**，考虑针对于查询字段建立索引时，**建议建立联合索引**，而非单列索引。可以避免回表查询。

## 索引设计原则

1、针对于**数据量较大**，且**查询比较频繁**的表建立索引。
2、针对于常作为**查询条件**（where）、**排序**（order by）、**分组**（group by）操作的字段建立索引。
3、 尽量选择**区分度高的列**作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4、如果是**字符串类型**的字段，字段的长度较长，可以针对于字段的特点，建立**前缀索引**。
5、尽量使用**联合索引**，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6、要**控制索引的数量**，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，**会影响增删改的效率**。
7、如果**索引列不能存储NULL值**，请在创建表时**使用NOT NULL约束**它。当**优化器**知道每列是否包含NULL值时，它可以**更好地确定哪个索引最有效地用于查询**。

# SQL性能分析

MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信
息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```mysql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';-- 7个字符
```

Com_insert: 插入次数

Com_select: 查询次数

Com_update: 更新次数

Com_delete: 删除次数

通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据
库优化提供参考依据。 

如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是**以查询为主，那么就要考虑对数据库的索引进行优化了**。

## 慢查询日志

慢查询日志记录了所有**执行时间超过指定参数**（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。
MySQL的慢查询日志**默认没有开启**，我们可以查看一下系统变量 slow_query_log。

要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：

```properties
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

查看慢日志文件中记录的信息地址：/var/lib/mysql/localhost-slow.log

## profile详情

show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling
参数，能够看到当前MySQL是否支持profile操作：

```mysql
SELECT @@have_profiling;
```

可以通过set语句在session/global级别开启profiling：

```properties
SET profiling = 1;
```

然后通过如下指令查看指令的执行耗时：

```mysql
-- 查看每一条SQL的耗时基本情况
show profiles;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

## explain

EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行
过程中表如何连接和连接的顺序。

```mysql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

Explain 执行计划中各个字段的含义:

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-10.png)

type中NULL表示不访问表，system表示访问系统表，const表示根据主键或唯一字段查询，ref表示根据普通字段查询，index表示扫描整个索引，all表示全表扫描。

# SQL优化

## 插入数据优化

insert插入数据的优化：

1、批量插入数据，将多条插入语句合并成一句

2、手动控制事务，自动事务提交会每插入一次就提交一次，性能差

3、按主键顺序插入，性能要高于乱序插入。

一次性需要插入**大批量数据**，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的**load指令**进行插入。

```mysql
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p
-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table tb_user fields
terminated by ',' lines terminated by '\n' ;
-- 主键顺序插入性能高于乱序插入
```

## 主键优化

在InnoDB存储引擎中，表数据都是根据**主键顺序组织存放**的，这种存储方式的表称为索引组织表，行数据，都是存储在聚集索引的叶子节点上的。

在InnoDB引擎中，数据行是记录在**逻辑结构 page 页**中的，页与页之间会通过指针连接，页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。

在**主键乱序插入**时，会出现**页分裂**，即b树的平衡操作，降低插入性能。

当**删除一行记录**时，实际上记录**并没有被物理删除**，只是**记录被标记**（flaged）为删除并且它的空间变得允许被其他记录声明使用。

当页中**删除的记录**达到 **MERGE_THRESHOLD**（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将**两个页合并以优化空间**使用。

**主键设计原则**

1、满足业务需求的情况下，尽量降低主键的长度。二级索引中存储了主键，可以减少占用。
2、插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
3、尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
4、业务操作时，避免对主键的修改。

## order by优化

MySQL的排序，有两种方式：

1、Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在**排序缓冲区**sort buffer中**完成排序操作**，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。
2、Using index : 通过有序索引顺序扫描**直接返回有序数据**，这种情况即为 using index，不需要额外排序，**操作效率高**。

查询排序和索引排序顺序相反时会**反向扫描**，输出结果。MySQL8版本中，支持降序索引，我们也可以创建降序索引。

排序时,使用联合索引也需要满足**最左前缀法则**，与查询不同，**顺序要严格一致**。

排序时,使用联合索引查询和索引**排序顺序冲突**，无法使用索引。

**order by优化原则**

1、根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
2、尽量使用覆盖索引。
3、多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
4、如果不可避免的出现filesort，大数据量排序时，可以适当**增大排序缓冲区**大小sort_buffer_size(默认256k)。

## group by优化

分组操作在联合索引中，也是符合最左前缀法则的。同查询操作，只需要存在左侧字段，不需要严格顺序一致。

1、在分组操作时，可以通过索引来提高效率。
2、分组操作时，索引的使用也是满足最左前缀法则的。

## limit优化

在数据量比较大时，如果进行limit分页查询，在查询时，通过链表进行遍历，**越往后，分页查询效率越低**。

一般分页查询时，通过创建 **覆盖索引** 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。即**分页查询主键**，然后通过主键子查询需要的字段。

## count优化

MyISAM 引擎把一个表的**总行数**存在了磁盘上，因此执行 count() 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。
InnoDB 引擎执行 count() 的时候，需要把数据一行一行地从引擎里面读出来**不为NULL**的，然后**累积计数**。

要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数
据库进行,但是不适用带条件的count)。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-11.png)

按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count( * )，所以尽量使用 count( * )。

## update优化

InnoDB的**行锁**是针对**索引**加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为**表锁** 。

update操作时**查询索引字段**，可以使用行锁，提高性能。

# 视图

视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的**查询中使用的表**，并且是在使用视图时动态生成的。

```mysql
-- 创建
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]
-- 查看创建视图语句：
SHOW CREATE VIEW 视图名称;
-- 查看视图数据：
SELECT * FROM 视图名称 ...... ;
-- 修改 两种方法
CREATE OR REPLACE VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH
[ CASCADED | LOCAL ] CHECK OPTION ]
ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |
LOCAL ] CHECK OPTION ]
-- 删除
DROP VIEW [IF EXISTS] 视1 图名称 [视图名称] ...
```

视图数据的插入、更新数据直接对**基表**进行操作。

## 检查选项

当使用**WITH CHECK OPTION**子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其**符合视图的定义**。 MySQL允许基于另一个视图创建视图，它还会**检查依赖视图中的规则以保持一致性**。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。

对数据的操作不符合视图定义时会报错。

CASCADED：当前视图的所有依赖视图的规则也会合并进行检查，无视检查条件

LOCAL：对当前视图的规则进行检查，然后根据上层所有依赖的视图的检查条件进行检查

## 视图的更新

要使视图**可更新**，视图中的行与基础表中的**行之间必须存在一对一的关系**。如果视图包含以下任何一项，则该视图不可更新：
1、聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）
2、DISTINCT
3、GROUP BY
4、HAVING
5、UNION 或者 UNION ALL

## 视图的使用

1、简化操作：将经常使用的查询定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。通常用于多表联查的情况。

2、安全性：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。

3、数据独立：视图可帮助用户屏蔽真实表结构变化带来的影响。

# 存储过程

# 锁

MySQL中的锁，按照锁的粒度分，分为以下三类：
1、全局锁：锁定数据库中的所有表。
2、表级锁：每次操作锁住整张表。
3、行级锁：每次操作锁住对应的行数据。

## 全局锁

全局锁就是对**整个数据库实例加锁**，加锁后整个实例就处于**只读状态**，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

**使用场景是做全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

```mysql
-- 加全局锁
flush tables 1 with read lock;
-- 数据备份
mysqldump -uroot –p1234 itcast > itcast.sql
-- 释放锁
unlock tables;
```

1、如果在**主库上备份**，那么在备份期间都不能执行更新，**业务基本上就得停摆**。
2、如果在**从库上备份**，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致**主从延迟**。

在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成**不加锁的一致性数据备份**(快照读)。

```mysql
mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```

## 表级锁

表级锁，每次操作**锁住整张表**。锁定粒度大，发生锁冲突的概率高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。

表级锁，主要分为以下三类：
1、表锁
2、元数据锁（meta data lock，MDL）
3、意向锁

### 表锁

对于表锁，分为两类：
1、表共享读锁（read lock）
2、表独占写锁（write lock）

**语法**：
加锁：lock tables 表名... read/write。
释放锁：unlock tables / 客户端断开连接 。

对指定表加了**读锁**，不会影响并发读操作，但是会阻塞并发写操作。

对指定表加了**写锁**，会阻塞并发的读和写操作。

### 元数据锁

MDL加锁过程是**系统自动控制**，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是**维护表元数据的数据一致性**，**在表上有活动事务的时候，不可以对元数据进行写入操作**。为了避免DML与DDL冲突，保证读写的正确性。

元数据，简单理解就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-12.png)

### 意向锁

为了避免DML在执行时，加的**行锁与表锁的冲突**，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用**意向锁来减少表锁的检查**，加表锁时**直接检查意向锁**获取是否存在行锁。

1、意向共享锁(IS): 由语句select ... lock in share mode添加 。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
2、意向排他锁(IX): 由insert、update、delete、select...添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。

一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。

## 行级锁

**行级锁**，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，**并发度最高**。应用在InnoDB存储引擎中。
InnoDB的数据是基于索引组织的，**行锁**是通过对**索引**上的索引项加锁来实现的，而不是对记录加的锁。

1、行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。

2、间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。

3、临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

### 行锁

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

类似读锁和写锁的关系。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-13.png)

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 **next-key 锁**进行搜索和索引扫描，以防止幻读。

1、针对**唯一索引**进行检索时，对已存在的记录进行**等值匹配**时，将会自动优化为**行锁**。

2、InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为**表锁**。

### 间隙锁&临键锁

1、索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。

2、索引上的等值查询(非唯一普通索引)，next-key lock 退化为间隙锁，在索引的两侧加间隙锁，符合值加行锁。

3、索引上的范围查询(唯一索引)--在范围的两侧加间隙锁，符合值加行锁。

间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。

# InnoDB引擎

1、表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。

2、段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。

3、区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。

4、页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。

5、行，InnoDB 存储引擎数据是按行进行存放的。

在行中，默认有两个隐藏字段：

1）Trx_id：每次对某条记录进行改动时，都会把对应的**事务id**赋值给trx_id隐藏列。
2）Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到**该记录修改前的信息**。

## 架构

MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-11.jpg)

### 内存结构

一、Buffer Pool

  InnoDB存储引擎基于磁盘文件存储，访问**物理硬盘和在内存中进行访问**，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到**缓冲池**中，避免每次访问都进行磁盘I/O。

  在InnoDB的缓冲池中不仅**缓存了索引页和数据页**，还包含了**undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息**等等。

  缓冲池 **Buffer Pool**，是**主内存中的一个区域**，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而**减少磁盘IO**，加快处理速度。

  缓冲池以Page页为单位，底层采用**链表数据结构**管理Page。根据状态，将Page分为三种类型：
1、free page：空闲page，未被使用。
2、clean page：被使用page，数据没有被修改过。
3、dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。

  在专用服务器上，**通常将多达80％的物理内存**分配给**缓冲池** 。参数设置： show variables
like 'innodb_buffer_pool_size';

二、Change Buffer

  Change Buffer，**更改缓冲区**（针对于非唯一二级索引页），在执行**DML语句**时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来**数据被读取**时，再将**数据合并**恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

三、Adaptive Hash Index

**自适应hash索引**，用于**优化对Buffer Pool数据的查询**。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。

**InnoDB存储引擎会监控**对表上各索引页的查询，如果观察到在**特定的条件下hash索引可以提升速度，则建立hash索引**，称之为自适应hash索引。

**自适应哈希索引**，无需人工干预，是系统根据情况自动完成。

参数： adaptive_hash_index

四、Log Buffer

Log Buffer：**日志缓冲区**，用来保存要写入到磁盘中的**log日志数据**（redo log 、undo log），默认大小为 **16MB**，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。

参数:

innodb_log_buffer_size：缓冲区大小
innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：

1: 日志在每次事务提交时写入并刷新到磁盘，**默认值**。
0: 每秒将日志写入并刷新到磁盘一次。
2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。

### 磁盘结构

一、System Tablespace

**系统表空间**是**更改缓冲区**的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)

参数：innodb_data_file_path

系统表空间，默认的文件名叫 ibdata1。

二、File-Per-Table Tablespaces

如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。

开关参数：innodb_file_per_table ，该参数默认开启。

三、General Tablespaces

**通用表空间**，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。

```mysql
-- 创建表空间
CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE 1 = engine_name;
-- 创建表时指定表空间
CREATE TABLE xxx ... TABLESPACE ts_name;
```

四、Undo Tablespaces

**撤销表空间**，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。

五、Temporary Tablespaces

InnoDB 使用**会话临时表空间和全局临时表空间**。存储用户创建的临时表等数据。

六、Doublewrite Buffer Files

**双写缓冲区**，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。

七、Redo Log

**重做日志**，是用来**实现事务的持久性**。该日志文件由两部分组成：**重做日志缓冲**（redo log buffer）以及**重做日志文件**（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。两个文件进行循环使用。

### 后台线程

在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。

1、Master Thread
**核心后台线程**，**负责调度其他线程**，还负责将**缓冲池中的数据异步刷新到磁盘**中, 保持数据的一致性，还包括**脏页的刷新、合并插入缓存、undo页的回收** 。

2、IO Thread
在InnoDB存储引擎中大量使用了**AIO来处理IO请求**, 这样可以极大地提高数据库的性能，而IO
Thread主要负责这些IO请求的回调。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-14.png)

3、Purge Thread
主要用于**回收事务**已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。

4、Page Cleaner Thread
协助 Master Thread **刷新脏页到磁盘的线程**，它可以减轻 Master Thread 的工作压力，减少阻塞。

## 事务原理

**事务** 是一组操作的集合，它是一个**不可分割的工作单位**，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

1、原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
2、一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
3、隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环
境下运行。
4、持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

其中的**原子性、一致性、持久性**，实际上是由InnoDB中的**两份日志**来保证的，一份是redo log日志，一份是undo log日志。 而**隔离性**是通过**数据库的锁**，加上**MVCC**来保证的。

### redo log

**重做日志**，记录的是事务提交时数据页的**物理修改**，是用来实现事务的**持久性**。
该日志文件由两部分组成：**重做日志缓冲**（redo log buffer）以及**重做日志文件**（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把**所有修改信息都存到该日志文件**中, 用于在刷新脏页到磁盘,发生错误时, 进行**数据恢复**使用。

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-12.jpg)

1、如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了**事务的持久性**。

2、而如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的**两个redo log文件是循环写的**。

3、在业务操作中，我们操作数据一般都是**随机读写磁盘**的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。**顺序写的效率，要远大于随机写**。这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。

### undo log

**回滚日志**，用于记录数据被修改前的信息 , 作用包含两个 : **提供回滚**(保证事务的原子性) 和**MVCC**(多版本并发控制) 。

undo log和redo log记录物理日志不一样，它是**逻辑日志**。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

undo log在事务执行时产生，**事务提交时，并不会立即删除undo log**，因为这些日志可能还用于MVCC。

undo log采用**段**的方式进行管理和记录，存放在 rollback segment回滚段中。

## MVCC

全称 Multi-Version Concurrency Control，**多版本并发控制**。指**维护一个数据的多个版本**，使得**读写操作没有冲突**，**快照读**为MySQL实现MVCC提供了一个**非阻塞读功能**。MVCC的具体实现，还需要依赖于数据库记录中的**隐式字段、undo log日志、readView**。

1、**当前读**

**读取的是记录的最新版本**，读取时还要**保证其他并发事务不能修改当前记录**，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ...for update、update、insert、delete(排他锁)都是一种**当前读**。

2、**快照读**
简单的select（不加锁）就是快照读，快照读，**读取的是记录数据的历史版本**，不加锁，**是非阻塞读**。

• Read Committed：每次select，都生成一个快照读。

• Repeatable Read：开启事务后第一个select语句才是快照读的地方。后面重复读会直接读取快照。

• Serializable：快照读会退化为当前读。

**隐藏字段**

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-15.png)

**undo log**

**回滚日志**，在insert、update、delete的时候产生的便于数据回滚的日志。当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。

**undo log 版本链**

不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条**记录版本链表**，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

<img src="C:\Users\25798\OneDrive\Notes\image\MySQL2-13.jpg" alt="MySQL" style="zoom: 67%;" />

**readview**

ReadView（读视图）是 **快照读 SQL执行时MVCC提取数据的依据**，记录并维护系统当前**活跃的事务（未提交的）id**。

ReadView中包含了四个核心字段：

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-16.png)

![MySQL](C:\Users\25798\OneDrive\Notes\image\MySQL2-17.png)

不同的隔离级别，生成ReadView的时机不同：

READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。

REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。

# MySQL管理

