# 日志

## 错误日志

**错误日志**是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何**严重错误时的相关信息**。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。
该日志是**默认开启**的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志位置：

```mysql
show variables like '%log_error%';
```

## 二进制日志

二进制日志（BINLOG）记录了所有的 **DDL**（数据定义语言）语句和 **DML**（数据操纵语言）语句，但**不包括数据查询**（SELECT、SHOW）语句。
作用：①. 灾难时的**数据恢复**；②. MySQL的**主从复制**。在MySQL8版本中，**默认二进制日志是开启**着的，涉及到的参数如下：

```mysql
show variables like '%log_bin%';
```

MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：

![](C:\Users\25798\OneDrive\Notes\image\MySQL2-18.png)

```mysql
show variables like '%binlog_format%';
```

可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。

```mysql
show variables like '%binlog_expire_logs_seconds%';
```

## 查询日志

查询日志中记录了客户端的**所有操作语句**，默认情况下，查询日志是**未开启**的。

如果需要开启查询日志，可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：

```properties
#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启
general_log=1
#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log
general_log_file=mysql_query.log
```

开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，该日志文件将会非常大。

## 慢查询日志

**慢查询日志**记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为10 秒，最小为 0， 精度可以到微秒。
如果需要开启慢查询日志，需要在MySQL的配置文件 /etc/my.cnf 中配置如下参数：

```properties
#慢查询日志
slow_query_log=1
#执行时间参数
long_query_time=2
#记录执行较慢的管理语句
log_slow_admin_statements =1
#记录执行较慢的未使用索引的语句
log_queries_not_using_indexes = 1
```

# 主从复制

主从复制是指将主数据库的 **DDL 和 DML** 操作通过**二进制日志**传到从库服务器中，然后在从库上对这些**日志重新执行**（也叫重做），从而使得从库和主库的**数据保持同步**。

MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。

MySQL 复制的优点主要包含以下三个方面：
1、主库出现问题，可以**快速切换到从库**提供服务。
2、实现**读写分离**，降低主库的访问压力。
3、可以在**从库中执行备份**，以避免备份期间影响主库服务。

MySQL主从复制的核心就是 **二进制日志**，具体的过程如下：

1、Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。

2、从库中 IOthread 读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。

3、从库中 SQLthread 重做中继日志中的事件，将改变反映它自己的数据。

对于大事务或资源密集型操作，**直接在主库上执行**，避免从库的额外延迟，降低**主从延迟**。

## 搭建



# 分库分表

应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：

1、**IO瓶颈**：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。

2、**CPU瓶颈**：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。

为了解决上述问题，我们需要对数据库进行分库分表处理。

**分库分表**的中心思想都是**将数据分散存储**，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到**提升数据库性能**的目的。

## 拆分策略

分库分表的形式，主要是两种：**垂直拆分和水平拆分**。而拆分的粒度，一般又分为**分库和分表**。

**垂直分库**

以**表**为依据，根据业务将不同表拆分到不同库中。
1、每个库的表结构都不一样。
2、每个库的数据也不一样。
3、所有库的并集是全量数据。

**垂直分表**

以**字段**为依据，根据字段属性将不同字段拆分到不同表中。
1、每个表的结构都不一样。
2、每个表的数据也不一样，一般**通过一列（主键/外键）关联**。
3、所有表的并集是全量数据。

**水平分库**

以**字段**为依据，按照一定策略，将一个库的数据拆分到多个库中。
1、每个库的表结构都一样。
2、每个库的数据都不一样。
3、所有库的并集是全量数据。

**水平分表**

以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。
1、每个表的表结构都一样。
2、每个表的数据都不一样。
3、所有表的并集是全量数据。

## 分片规则

在水平拆分时可用的分片规则如下所示。

### 范围分片

根据指定的**字段**及其**配置的范围与数据节点的对应情况**， 来决定该数据属于哪一个分片。

该分片规则，主要是针对于**水平拆分**中**数字类型**的字段适用。例如0-500万之间的值，存储在0号数据节点(数据节点的索引从0开始) ； 500万-1000万之间的数据存储在1号数据节点 ； 1000万-1500万的数据节点存储在2号节点 ；

### 取模分片

根据指定的**字段值**与**节点数量**进行**求模运算**，根据运算结果， 来决定该数据属于哪一个分片。

该分片规则，主要是针对于**水平拆分**中**数字类型**的字段适用。

### 一致性hash分片

所谓一致性哈希，**相同的哈希因子计算值总是被划分到相同的分区表中**，不会因为分区节点的增加而改变原来数据的分区位置，有效的**解决了分布式数据的拓容问题**。任何类型字段都可以使用，不仅仅是数字。

### 枚举分片

通过在配置文件中配置可能的**枚举值**, 指定数据分布到**不同数据节点**上, 本规则适用于按照省份、性别、状态拆分数据等业务 。

### 应用指定算法

运行阶段由**应用自主决定**路由到那个分片 , 直接根据字符子串（必须是数字）计算分片号。

### 固定分片hash算法

该算法类似于十进制的求模运算，但是为二进制的操作，例如，取 id 的二进制低 10 位 与1111111111 进行位 & 运算，位与运算最小值为 0000000000，最大值为1111111111，转换为十进制，也就是位于0-1023之间。然后再进行范围分片。

1、如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。
2、可以均匀分配，也可以非均匀分配。
3、分片字段必须为数字类型。

### 字符串hash解析算法

截取字符串(uuid)中的指定位置的子字符串, 进行固定分片hash算法， 算出分片。

### 按天分片算法

按照日期及对应的时间周期来范围分片。

### 自然月分片

使用场景为按照月份来分片, 每个自然月为一个分片。

## 实现技术

shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。
**MyCat**：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。

# 读写分离

读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。**主数据库提供写操作，从数据库提供读操作**，这样能有效地减轻单台数据库的压力。同时通过**主从复制**保证数据的一致性。可以通过mycat来实现。

一主一从架构，而当主节点Master宕机后，业务系统就只能够读，而不能写入数据了。

**双主双从**
一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、Master2 互为备机。

