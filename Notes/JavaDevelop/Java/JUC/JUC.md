[TOC]

# JUC

juc：java.util.concurrent并发工具包

**start线程**

启动一个线程使用start函数，外部同步锁，内部调用**操作系统**native函数start0()

**OpenJDK**网站中可以查看c++编写的native函数

**并发(concurrent)和并行(parallel)**

进程：操作系统中每一个应用程序就是一个进程

线程：进程中存在多个线程，线程是操作系统进行调度时的基本单元

管程：Monitor监视器，也就是锁，保证同步对象同一时间只有一个线程可以访问

## 线程

分为**用户线程**(默认)和**守护线程**

用户线程：系统的**工作线程**

守护线程：是为其他线程服务的特殊线程，在后台完成系统性的服务，例如**垃圾回收线程**

守护线程仅作为服务线程，当系统只剩下守护线程的时候，java虚拟机就可以关闭了。

```java
isDaemon();// 是否是守护线程
setDaemon();// 设置守护线程，必须在start之前设置
```

main函数会创建一个main的主线程(用户线程)

**wait()**方法是 Object 的方法，任何对象实例都能调用，wait 会释放锁，但调用它的前提是当前线程占有锁，可以被 interrupted 方法中断。

**sleep()**方法是 Thread 的静态方法，sleep 不会释放锁，它也不需要占用锁，可以被 interrupted 方法中断。

# CompletableFuture

## Future

Future接口(FutureTask实现)定义了操作异步任务的一些方法，如获取执行结果、取消任务执行等。主要用于主线程对于子线程的操作。

1、Runnable接口无返回值，无异常抛出

2、Callable接口有返回值，有异常抛出

FutureTask通过构造注入，可以实现两者的注入。

**构造方法：**

1、FutureTask(Callable < V > callable)

2、FutureTask(Runnable runnable， V result)

**获得返回值：**futureTask.get()

**优点：**

Future加线程池异步多线程任务能显著提高程序的执行效率。

**缺点：**

1、get()方法会等待线程完成任务后获取返回值才能继续，容易导致阻塞。一般将get()方法放在程序后面，也可以**get(数值，TimeUnit.SECONDS)**设定限时取消任务。

2、isDone()方法判断线程是否完成，一般要通过轮询的方式，耗费cpu资源

一般使用轮询的方式获取返回值，避免阻塞。

## CompletableFuture

阻塞的方式不符合异步编程的设计理念，轮询又会耗费cpu资源

JDK8设计出了CompletableFuture来解决这些问题，扩展了Future，提供了一种类似**观察者模式**的机制，可以让任务执行完成后通知监听的一方。提供了函数式编程，可以通过回调的方式处理计算结果，提供了转换和组合的方法。

官方建议通过**静态方法来构造**：

1、无返回值runAsync

public static CompletableFuture< Void > runAsync(Runnable runnable);

public static CompletableFuture< Void > runAsync(Runnable runnable, Executor executor);

2、有返回值supplyAsync

public static CompletableFuture< Void > supplyAsync(Supplier< U > supplier);

public static CompletableFuture< Void > supplyAsync(Supplier< U > supplier, Executor executor);

对象supplier没有入参，需要有返回值。

同样get()方法**获取返回值**，也可以使用join()，区别在于**不会汇报异常**

没有指定**线程池**，将会使用默认的**ForkJoinPool.commonPool()**

**支持链式调用**：whenComplete()线程完成任务后**自动执行**，exceptionally()获取异常情况

## 函数式接口

Runnable接口：无参数、无返回值、run()方法

Function接口：一个参数，有返回值、apply()方法

Consumer接口：一个参数，无返回值、accept()方法

BiConsumer接口：两个参数，无返回值、accept()方法

Supplier接口：没有参数，有返回值、get()方法

## 多线程异步任务同时查询比价

略

# 线程锁

## 悲观锁

synchronized和Lock的实现类都是悲观锁

认为使用数据时**一定会有别的线程来修改数据**，需要**确保数据不会被别的线程修改**。

适用于**写操作多**的场景，任意出现多线程问题。**显式的锁定**之后再同步资源。

## 乐观锁

认为使用数据时**不会有别的线程来修改数据**，不需要添加锁。

底层不需要锁，需要在更新数据的时候去判断之前数据有没有被其他线程更新过。

如果被更新过，就进行放弃修改、重试抢锁等

**判断规则：**

1、版本号机制

2、CAS算法，java原子类中的递增操作就是通过CAS自旋实现的

适合**读操作多**的场景，能大幅提高读操作的性能

## synchronized

底层字节码指令为：

同步代码块 1、**加锁** 2、**释放锁** 3、异常情况下**释放锁**

静态和普通方法 **加锁的标识flag**

1、类中**方法加了锁**，只要一个上锁的方法被访问，**锁的是当前对象this**，当前对象中的**所有上锁方法**都**不能被其他线程访问**，但是其他未上锁方法可以正常被访问。

2、类中**静态方法加了锁**，只要一个上锁的方法被访问，**锁的是当前类**，当前类中的**所有上锁方法**都**不能被其他线程访问**，但是其他未上锁方法可以正常被访问。

3、**同步代码块**锁的是括号中的对象

4、**类锁**和**对象锁**互不影响，可以同时访问。

5、synchronized 关键字不能被继承，子类方法默认不是同步的。

## 公平锁

锁被释放之后，**先申请的线程先得到锁**。**性能较差一些**，因为公平锁为了保证时间上的绝对顺序，线程切换更频繁。

## 非公平锁(默认)

锁被释放之后，后申请的线程可能会先获取到锁，是**随机或者按照其他优先级排序**的。**性能更好**，能尽量充分利用cpu时间，减少了线程切换的开销，但可能会导致某些线程永远无法获取到锁。

## 可重入锁(递归锁)

在同一个线程**外层方法获取锁**后，再次进入**该线程**的**内层方法**会**自动获取锁**(需要锁是一个对象)，**不会被阻塞**。

尤其在**递归调用过程**中，可以**避免死锁**。

ReentrantLock和synchronized都是**可重入锁**。

**隐式锁**(synchronized)为**默认为可重入锁**，底层实现了可重入锁机制。

**显式锁**为**需要**自行配对释放的锁，例如ReentrantLock。

**java中所有对象都可以作为锁，因为Object底层实现了ObjectMonitor来实现锁的功能。**

底层锁对象有一个**锁计数器**和一个**指针指向持有锁的线程(线程ID)**，重入计数器、阻塞队列、等待队列

1、如果计数器为0，则指针指向当前线程，计数器加1

2、如果计数器不为0，当前线程是指针指向的线程，则计数器加1，进入阻塞队列

3、执行释放锁时，计数器减1，计数器为0则锁被释放

## 死锁

指两个或两个以上的线程因争夺资源而造成的一种**互相等待**的现象。

排查死锁：

1、jps -l 命令查看当前进程

2、jstack 进程号

3、可以看出是否发现死锁

或者使用jconsole

# 中断机制

java中不推荐直接停止一个线程，提供了一种**中断**的协商机制，由线程自己判断是否停止。

需要手动调用该线程的**interrupt方法**，将线程对象的**中断标识**设成true；

 ```java
 public void interrupt();//将线程的中断标识设为true
 public static boolean interrupted();//判断线程是否被中断并返回，然后清除当前中断状态，将中断标识设置为false
 public boolean isInterrupted();//判断线程是否被中断并返回，和上一个方法底层相同，只是不需要清除中断状态。
 ```

1、可以通过volatile变量来实现一个中断标识的作用

2、通过AtomicBoolean类实现中断标识

3、使用上面提到的interrupt方法实现中断效果

如果线程在**被阻塞状态(sleep, wait, join)下被调用interrupt方法**，线程将**退出被阻塞状态**，**方法抛出中断异常，中断标识被清除**。对于不活动的线程，中断不起作用，标识始终为false。

被中断线程需要在阻塞状态处捕获中断异常，重新二次调用中断方法。

# Lock接口

Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。

**synchronized 不需要用户去手动释放锁**，当 synchronized 方法或者 synchronized 代码块执行完之后， **系统会自动让线程释放对锁的占用**；而 **Lock 则必须要用户去手动释放锁**，如 果没有主动释放锁，就有可能导致出现**死锁**现象。

**Lock 必须在 try{}catch{}块中进行**，并且将**释放锁的操作放在finally块**中进行，以保证锁一定被被释放，防止**死锁**的发生。

```java
Lock lock = new ReentrantLock();//ReentrantLock可重入锁
lock.lock();
try {
	//处理任务
} catch(Exception ex) {
} finally {
	lock.unlock(); //释放锁
}
```

ReentrantReadWriteLock通过readLock()和 writeLock()用来获取读锁和写锁。

# LockSupport

线程的阻塞和唤醒，同时可以实现**线程间的交互**：

1、新建一个Object类的作为synchronized的锁对象。使用Object中的wait()方法让线程等待，notify()方法唤醒线程。方法必须在同步代码块内部使用，要先wait后notify。

2、使用ReentrantLock中的Condition的await()方法让线程等待，signal()方法唤醒线程。同上，必须持有lock才能使用方法，必须先await再signal。

3、直接使用LockSupport中的park()方法和unpark()方法来进行线程的阻塞和唤醒，无锁块要求，支持先唤醒后等待。

LockSupport使用了一种**permit许可**来实现阻塞唤醒功能。许可数量上限只有1。

```java
public static void park();//无通行证就阻塞，等待获取通行证后唤醒
public static void unpark(Thread thread);//发放通行证
```

无通行证调用park方法当前线程就会阻塞，直到别的线程给当前线程方法permit，park方法才会被唤醒。

方法底层使用了unsafe类中的方法，不安全，易造成内存泄漏。

# 集合线程安全

**ArrayList**集合不允许多线程操作读写。

Vector集合通过加synchronized关键字来保证线程安全，效率太低，已经被淘汰。

Collections工具类中提供了同步List。

JUC包中提供了**CopyOnWriteArrayList**集合，来实现高性能的线程安全。

利用了Copy On Write写时复制技术，并发读，当需要修改内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作。适合**读多写少**的并发场景，能够极大地提高系统的并发性能。

缺点：

1、内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。

2、写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。

3、数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。

CopyOnWriteArraySet是HashSet的多线程版本，ConcurrentHashMap是HashMap的多线程版本。

# 常用辅助类

## CountDownLatch

**减少计数类**，使用**CountDownLatch类**判断线程是否全部操作完毕：

```java
CountDownLatch countDownLatch = new CountDownLatch(线程数);
// 下面线程操作：
new Thread(() -> {
    try {
        // 具体操作
    } finally {
        countDownLatch.countDown();
    }
}).start();
countDownLatch.await(); // 等待线程数全部结束后唤醒
// 获取结果
```

## CyclicBarrier

**循环栅栏类**，允许一组线程互相等待，直到到达某个公共屏障点。

![JUC12](C:\Users\25798\OneDrive\Notes\image\JUC12.png)

## Semaphore

**信号量类**，构造方法中传入的第一个参数是最大**信号量**（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可。

```java
Semaphore(int permits);// 初始化许可数和非公平设置
Semaphore(int permits, boolean fair);// 初始化许可数和给定的公平设置
semaphore.acquire();// 获取一个许可，在提供许可前一直将线程阻塞
semaphore.release();// 释放一个许可，将其加回信号量
```

# 阻塞队列

**BlockingQueue**，高效并且线程安全的队列类，解决了多线程间数据通信的问题。封装了阻塞线程和唤醒线程的过程，简化了开发。

1、当队列是空的，从队列中获取元素的操作将会被阻塞

2、当队列是满的，从队列中添加元素的操作将会被阻塞

先进先出（FIFO）：先插入的**队列**的元素也最先出队列，类似于排队的功能。 从某种程度上来说这种队列也体现了一种公平性

后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(**栈**)

**“生产者”和 “消费者”模型**中，通过**队列**可以很便利地实现两者之间的**数据共享**。

![JUC13](C:\Users\25798\OneDrive\Notes\image\JUC13.png)

实现类：

1、**ArrayBlockingQueue** 基于数组的有界阻塞队列

维护了一个定长数组，两个整形变量，分别标识着队列的头部和尾部在数组中的位置。在生产者放入数据和消费者获取数据，都是**共用同一个锁对象**，由此也意味着两者无法真正并行运行。在插入或删除元素时不会产生或销毁任何额外的对象实例。可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。

2、**LinkedBlockingQueue **基于链表的有界阻塞队列

当队列缓冲区达到最大值缓存容量时（ 可以通过构造函数指定该值），才会阻塞生产者队列。于生 产者端和消费者端分别采用了**独立的锁**来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列 的并发性能。在插入或删除元素时会生成一个额外的 Node 对象。

3、DelayQueue 基于优先级队列实现的延迟无界阻塞队列

当其指定的**延迟时间**到了，才能够从队列中获取到该元素。DelayQueue是一个**没有大小限制**的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。

4、PriorityBlockingQueue 基于优先级的无界阻塞队列

不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。内部控制线程同步的锁采用的是**公平锁**。注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。

5、SynchronousQueue 无缓冲的等待队列

• 公平模式：会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；

• 非公平模式（默认）：采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式， 如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。

6、LinkedTransferQueue 链表结构组成的无界阻塞队列

采用一种预占模式。意思就是消费者线程取元素时，如 果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素 为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时 发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。

7、LinkedBlockingDeque 链表结构组成的双向阻塞队列

• 插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时 再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作 失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException异常

• 读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数

# 线程池

**线程过多**会带来**调度开销**， 进而**影响缓存局部性和整体性能**。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这**避免了在处理短时间任务时创建与销毁线程的代价**。线程池不仅能够保证内核的充分利用，还能防止过分调度。

1、降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。

2、提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。

3、提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

Java中的**线程池**是通过**Executor框架**实现的，该框架中用到了Executor，Executors， ExecutorService，ThreadPoolExecutor这几个类

```java
Executors.newFixedThreadPool(int);//一池N线程
Executors.newSingleThreadExecutor();//一池一线程
Executors.newCachedThreadPool();//可扩容线程池
```

参数一：corePoolSize : 指定线程池的**核心线程的数量**。

参数二：maximumPoolSize：指定线程池的**最大线程数量**。

参数三：keepAliveTime ：指定临时线程的存活时间。

参数四：unit：指定临时线程存活的时间单位(秒、分、时、天）

参数五：workQueue：指定线程池的**任务队列**。

参数六：threadFactory：指定线程池的线程工厂。

参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理）

1、任务数小于corePoolSize时，直接分配线程进行操作。

2、没有空闲线程时，会优先将任务放到workQueue队列中等待。

3、当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。

4、再提交更多的任务，则会触发线程池的拒绝策略。

当提交的任务数大于（workQueue.size() +  maximumPoolSize ），就会触发线程池的**拒绝策略**。

## 拒绝策略

**CallerRunsPolicy**: 当触发拒绝策略，只要线程池没有关闭的话，则**使用调用线程直接运行任务**。一般用于**并发比较小，性能要求不高，不允许失败**。但是，由于调用者自己运行任务，如果**任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大**。

**AbortPolicy**(**默认**): **丢弃任务**，并**抛出拒绝执行 RejectedExecutionException 异常**信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。

**DiscardPolicy**: **直接丢弃**，其他啥都没有

**DiscardOldestPolicy**: 当触发拒绝策略，只要线程池没有关闭的话，**丢弃阻塞队列** workQueue 中**最老的一个任务**，并**将新任务加入**

# Fork/Join分支合并框架

实现一个分治思想来进行操作，对象.fork()执行分支操作，对象.join()返回结果，并将返回值进行合并。

```java
// 新建对象
ForkJoinPool forkJoinPool = new ForkJoinPool();
forkJoinTask<Integer> forkJoinTask = forkJoinPool.submit(对象名);
System.out.println(forkJoinTask.get());
forkJoinPool.shutdown();
```

# JMM

java内存模型，与JVM中不同。用于屏蔽各种硬件和操作系统**内存的访问差异**。本质是一种**规范**，来定义程序中各个**变量的读写方式**并决定**一个线程对共享变量的写入何时以及如何变成对另一个线程可见**。

关键点围绕**多线程**的**原子性、可见性、有序性**

![JUC1](C:\Users\25798\OneDrive\Notes\image\JUC1.png)

系统**主内存**中的**共享变量**在**多线程并发**过程中很可能会出现“脏读”。**jmm**规定每个线程都有自己的**工作内存**，工作内存中保存线程使用的变量的**主内存副本**，线程对变量的操作需要在自己的工作内存中进行，不能直接写入系统主内存中。不同线程之间无法访问对方工作内存中的变量，线程间的变量传递需要通过主内存来完成。

可见性：当一个线程修改了某一个共享变量的值，其他线程可以立即知道该变更。

原子性：在多线程环境下，操作不能被其他线程干扰。

有序性：**JVM内部维持顺序化指令**，只有不影响程序输出的最终结果，那么就可以对**指令进行重排序**，可以与代码顺序不一致，来优化指令执行效率。

在**串行过程**中指令重排可以保证语义不变，但是在**多线程**中就有可能产生“脏读”

**重排序**必须要**遵循指令间**的**数据依赖性**。

![JUC2](C:\Users\25798\OneDrive\Notes\image\JUC2.png)

若两个操作访问**同一个变量**，且其中**一个操作为写操作**，则两操作就存在**数据依赖性**。

在某些场景下需要禁止编译器重排来保证数据的一致性。

## happens-before(先行发生)原则

操作执行后需要对另一个操作**可见性**，或者**代码重排序**，需要满足**先行发生原则**。

1、如果一个操作**先行发生**另外一个操作，那么第一个操作将对第二个**可见**，执行顺序第一个先于第二个。

2、如果两个操作存在**先行发生**关系，重排序就需要满足结果和**先行发生**关系顺序的结果一致，否则是非法的重排序。

细则：

1、次序规则

同一个程序中，前一个操作的结果可以被后续的操作获取

2、锁定规则

unLock操作先行发生于后面同一个锁的lock操作，即同一个锁必须先被释放然后才能再次获取。

3、volatile变量规则

volatile变量的写操作先行发生于后面的读操作。

4、传递规则

A先行发生B，B先行发生C，则A先行发生C

5、线程启动规则

线程对象的start()方法先行发生于此线程的所有操作

6、线程中断规则

线程的中断方法先行发生于后面的中断检测方法

7、线程终止规则

线程中的所有操作都先行发生于对此线程的终止检测方法isAive()

8、对象终结规则

一个对象的初始化完成先行发生于他的finalize()方法(JVM回收对象方法)

![JUC3](C:\Users\25798\OneDrive\Notes\image\JUC3.png)

# volatile

具有**可见性**和**有序性**(禁止重排序)

当写一个volatile变量时，JMM会把该线程对应的本地内存的共享变量值立即刷新回主内存。

当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回主内存中读取。

即volatile的读写相当于直接和主内存交互。

## 内存屏障

**内存屏障**是一类同步屏障指令，是CPU或编译器对内存随机访问操作的一个同步点，使此点之前所有读写操作执行都执行后才开始执行此点之后的操作，避免代码重排序。

内存屏障是一种JVM指令，java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令。**volatile**以此来实现**可见性和有序性**，但**无法保证原子性**。

内存屏障之前的写操作都要写回主内存。

内存屏障之后的读操作都能获取屏障之前的写操作的最新结果。

**写屏障**：处理器将屏障之前，执行完所有写入指令，储存在缓存中的数据同步到主内存中。

**读屏障**：处理器在屏障之后的读操作都在屏障之后执行，去主内存中获取数据。

写屏障、读屏障、全屏障(混合前面两种)都写在Unsafe类中，原生方法。

底层c++源码4种屏障类型：

![JUC4](C:\Users\25798\OneDrive\Notes\image\JUC4.png)

volatile的**有序性**就是通过内存屏障来禁止重排序。

![JUC5](C:\Users\25798\OneDrive\Notes\image\JUC5.png)

volatile读屏障：

![JUC6](C:\Users\25798\OneDrive\Notes\image\JUC6.png)

volatile写屏障：

![JUC7](C:\Users\25798\OneDrive\Notes\image\JUC7.png)

## 可见性

保证**不同线程**对变量操作后**所有线程及时可见**。

**普通变量**在多线程情况下使用的是**工作内存**，并不互通，所以**不具有即时可见性**。

volatile变量读写过程的八个**原子指令**，锁定和解锁只作用于**主内存的写过程**中：

![JUC8](C:\Users\25798\OneDrive\Notes\image\JUC8.png)

volatile变量**不具备原子性**，例如i++；volatile只保证**可见性**，即加载变量到工作内存时为最新值，但在加载后的变量变化并**不同步**到工作内存。**多线程操作变量**必须**加锁**才能保证volatile变量的**原子安全性**。

## 最佳实践

1、只有**单一赋值的变量**，不含i++等复合操作，**多线程下使用volatile**。例如布尔状态变量来判断重要事件的变量。

2、读多写少的变量加锁，**写操作加锁**，**读操作不加锁**，通过**volatile来保证读过程的可见性**。

3、多线程下的**双检测锁的单例模式**，在读操作时可能出现并发错误，可以通过volatile来保证读过程的**可见性**。本质是禁止读写的指令重排序。

# CAS

compare and swap，包括**内存偏移地址**、**预期旧值**和**更新值**。

1、如果**内存偏移地址的值**与**预期原值**相匹配，则更新该位置的值为**更新值**。

2、如果**内存偏移地址的值**与**预期原值**不匹配，则**不做任何操作**，或者**重新进行操作（即自旋）**。

CAS是JDK提供的**非阻塞原子性操作**，通过硬件保证了原子性和可靠性，原语的执行必须是连续的，不允许被中断，对应了**cpu的原子指令**，由**Unsafe类**提供。

问题：

1、如果CAS长时间一直循环不成功，会给cpu带来很大的开销。设置休眠时间循环来减少访问开销。

2、ABA问题，**CAS操作期间**变量经过其他线程**由A变为B后又变回A**，虽然操作成功，但中间过程可能会操作问题。**使用AtomicStampReference类**添加版本号来解决这个问题。

## AtomicReference类

可以**自定义类**作为原子类：

```java
AtomicReference<类名> atomicReference = new AtomicReference<>();
```

## 自旋锁

CAS是自旋锁的基础，自旋锁就是以**循环判断的锁**的状态来**获取被占用的锁**，**不会立即阻塞**，优点是**减少了线程切换的消耗**，缺点是**循环占用cpu资源**。

## Unsafe类

是CAS的核心类，Unsafe类可以直接像C的指针一样操作特定内存的数据，其中所有方法都是native原生方法。

# 原子类

在多线程环境下，使用原子类变量可以保证线程安全，且不用加锁，可以提高并发性能。利用**CAS保证原子性**，**volatile来保证有序性和可见性**。

## 基本类型原子类

**AtomicInteger、AtomicBoolean、AtomicLong**

方法：

![JUC9](C:\Users\25798\OneDrive\Notes\image\JUC9.png)

使用**CountDownLatch类**判断线程是否全部操作完毕：

```java
CountDownLatch countDownLatch = new CountDownLatch(线程数);
// 下面线程操作：
new Thread(() -> {
    try {
        // 具体操作
    } finally {
        countDownLatch.countDown();
    }
}).start();
countDownLatch.await(); // 等待线程数全部结束后唤醒
// 获取结果
```

## 数组类型原子类

**AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray**

方法同基本类型，入参增加一个下标i

## 引用类型原子类

**AtomicReference、AtomicStampedReference、AtomicMarkableReference**

AtomicStampedReference：增加**版本号**，表示**数据被修改过的次数**

AtomicMarkableReference：增加**布尔类型标记位**，表示**数据是否被修改过**

## 对象属性修改原子类

**AtomicIntegerFieldUpdate、AtomicLongFieldUpdate、AtomicReferenceFieldUpdate**

基于**反射**原理，以**线程安全**的方式操作**非线程安全对象**中的**字段**。

1、更新的对象属性必须使用public volatile修饰符

2、每次使用必须用静态方法newUpdater()创建一个更新器

## 原子操作增强类

从**JDK8**更新后加入。

DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder

高并发热门点赞计数使用**LongAdder**，性能更好。低并发下，与**AtomicLong**性能相似；高并发下**吞吐量明显更高，但空间消耗也更高**，可以减少乐观锁的次数。但是求值过程不具有原子性，不精确。

![JUC10](C:\Users\25798\OneDrive\Notes\image\JUC10.png)

LongAdder是一个**初始值为0**的加法器，只能用于**累加操作**；LongAccumulator**可以指定操作方法和初始值**。

LongAdder使用了**分散热点的思想**，使用一个**base作为基础变量**，**cell数组作为扩容(双倍扩容)分散的变量**。最终求和值为base和cell数组的所有变量和，但是**求和过程不是原子操作**。

底层通过**哈希值计算**线程id对应的**cell数组下标**，和HashMap相似。

1、初始只有base，进行cas操作

2、base出现cas操作失败后，新建cell[2]数组

3、通过hash映射操作对应的cell数组下标，如果cell数组正在新建或者扩容，则在base上操作。

4、如果cell数组中存在操作失败，就要对cell数组进行双倍扩容

上面步骤套在一个自旋for(;;)中

# ThreadLocal

实现**每个线程**都有自己**专属的本地变量副本**，**避免了线程安全问题**。

其并**不解决线程间共享数据**的问题，适用于线程间隔离且方法间共享的场景。

建议在**try-finally块**后对**ThreadLocal进行remove回收**，尤其在**线程池**中会存在**线程复用**。

![JUC11](C:\Users\25798\OneDrive\Notes\image\JUC11.png)

线程类**Thread**中有一个**ThreadLocal.ThreadLocalMap**类属性，**ThreadLocalMap**是**ThreadLocal**类的一个**静态内部类**。

**ThreadLocalMap**是一个**ThreadLocal对象为key**，对应值为**value**的**Entry对象**。

ThreadLocalMap类的双层包装：

```java
static class Entry extends WeakReference<ThreadLocal<?>> {}
// (Entry(WeakReference(ThreadLocal)))
```

利用ThreadLocal作为key标识，从Map中获取值来实现线程间的隔离。

因为Thread和ThreadLocal为两个不同的对象，在**线程销毁后ThreadLocal会被Entry继续引用**，会造成内存泄漏，而**弱引用始终都会被回收**，**大概率减少了内存泄漏**。

而**线程池**中**线程复用**，一直存在**Thread -> ThreadLocalMap**的强引用，会导致Entry中的key被回收，但是value没有被回收，存在大量key为null的value导致内存泄漏，必须手动调用remove()方法。

remove()方法中的expungeStaleEntry()方法，将key=null的value值设置为null

## 最佳实践

1、将ThreadLocal初始化，避免get()时空指针异常

2、建议用static修饰ThreadLocal，其只被定义一次就足够了

3、使用try...finally代码块手动remove()

# 对象内存布局

在JVM中，对象在堆内存中实例可以分为三部分：

1、对象头(Mark Word) 2、实例数据 3、对齐填充(保证8个字节的倍数，方便寻址)

**对象头**中含有**对象标记**和**类型指针**，数组对象中对象头多一个**数组的长度**。

**对象标记**中含有对象的**哈希码、GC标记、GC次数、同步锁标记、偏向锁持有者**

**类型指针**指向对象对应的方法区中的类Klass类元信息

**实例数据**中存放类的属性(Field)数据信息，包括父类的属性信息

**对齐填充**：JVM要求对象起始地址必须是8字节的整数倍，不包含实际内容，只是为了对齐字节。

64位系统中**对象头和类型指针都是8字节**，一共16字节。JDK8默认进行**指针压缩**，类型指针变成4字节。

![JUC14](C:\Users\25798\OneDrive\Notes\image\JUC14.png)

JDK8的JVM中分代年龄最高是15(默认)，因为只有4bit空间来存储年龄值。

对象中的hashcode需要调用生成方法才会存储，否则为0

# synchronized锁升级

**无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁**

synchronized锁由**对象头中的锁标志位**来采用不同的锁升级策略

Java中的线程是映射到操作系统的原生线程之上的，阻塞唤醒线程需要在**用户态**和**核心态**直接切换，会消耗大量的系统资源。JDK6之后引入了锁升级来解决这个问题。

![JUC15](C:\Users\25798\OneDrive\Notes\image\JUC15.png)

偏向锁对象头中存储偏向的线程ID，轻量锁对象头中存储指向线程栈中Lock Record的指针，重量锁存储指向堆中的monitor对象的指针。

## 锁升级

无锁(001)：初始状态，对象被实例化后还没有被任何线程竞争锁

偏向锁(101)：当**线程第一次竞争到锁**时，变成偏向模式，如果不存在其他线程竞争，始终都是同一个线程来竞争，将不需要同步操作，该线程在后续访问时会自动获得锁。

偏向锁解决**大多数情况下，锁只被一个线程竞争**的性能优化。对象头中记录偏向线程的ID，每次同步只需要检查进程ID是否是偏向线程，如果是，则直接执行，无需加锁。如果不是，表示发生了竞争，将会用CAS替换对象头里的线程ID。如果竞争成功，则偏向线程改为新线程的ID，依然保持偏向锁。如果竞争失败，则可能需要升级为轻量级锁。

在全局安全点时，检查偏向线程是否还在执行。若已退出，则撤销偏向锁，变为无锁状态。若未退出，则升级为轻量级锁，轻量级锁由原来的偏向线程持有，正在竞争的线程会进入自旋等待。

从JDK6开始默认开启偏向锁，但是有4s的延迟启动时间。

JDK15开始废弃偏向锁，资源消耗大。

轻量级锁通过CAS自旋来减少资源消耗，提高性能，避免线程阻塞。

当自旋次数过多时，将会升级成重量级锁，JDK6之后自适应设定自旋的次数上限，由同一个锁上一次自旋的时间和拥有锁线程的状态来决定。、

轻量级锁在退出代码块后会主动释放，偏向锁则会一直保留，直到有其他线程竞争。

## 数据存储

因为偏向锁状态无法存储对象的哈希码，则计算过哈希码的无锁对象不会进入偏向锁状态，会直接升级成轻量级锁。

轻量级锁会将对象头中的数据拷贝到指向的Lock Record中，释放后拷贝回对象头。

重量级锁中指向的monitor类中会记录对象头中的数据，释放后写回对象头。

偏向锁收到哈希码请求时，会膨胀为重量级锁。

## 对比

**偏向锁**

优点：加锁解锁不需要额外操作，性能高

缺点：线程竞争后会有额外的撤销锁的资源消耗

场景：只有一个线程竞争

**轻量级锁**

优点：线程不会阻塞，响应速度高

缺点：大量线程自旋会消耗CPU资源

场景：追求响应时间，同步代码块执行速度快

**重量级锁**

优点：不会自旋消耗CPU

缺点：线程阻塞，响应时间慢

场景：追求吞吐量，同步代码块执行速度慢

## 锁消除

在同步方法每次调用时都会创建一个新的锁对象，无法起到同步作用，JIT编译器会无视此同步，进行锁消除。

## 锁粗化

相邻方法中前后使用的是同一个锁对象，JIT编译器会将这些方法合并成一个方法，减少锁使用的次数，来提升性能。

# AQS

AbstractQueuedSynchronizer抽象队列同步器，依赖于一个先进先出的双向链表等待队列(CLH 队列)，将等待请求资源的线程和其状态封装成节点对象Node，通过单个volatile的int值来表示占用和释放状态state，通过CAS实现对state的修改，是实现锁的公共基础框架，主要解决锁分配问题。抽象出来了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等。

利用AQS框架的：Semaphore、CyclicBarrier、ReentrantReadWriteLock、ReentrantLock、CountDownLatch

Node类：

![JUC16](C:\Users\25798\OneDrive\Notes\image\JUC16.png)

锁的类实现：

![JUC17](C:\Users\25798\OneDrive\Notes\image\JUC17.png)

1、抢占锁acquire()方法，**公平锁和非公平锁区别**是公平锁需要看队列中是否有前置节点，然后再进行CAS占据锁的state位，即tryAcquire()方法。抢占成功锁计数器加一(含可重入锁实现过程)。

2、抢占失败，加入等待队列，即addWait()方法中的enq()方法入队。

3、acquireQueued()方法循环调用等待队列，同时可以使用cancelAcquire()方法取消排队。调用后使用LockSupport.park()来挂起等待，将waitStatus改为-1(默认初始为0)。

4、释放锁调用tryRelease()方法，将state设置为0，当前线程设为null。访问队列中的节点，LockSupport.unpark()释放节点，重新进行tryAcquire()方法抢夺锁(因为非公平锁情况下可能被其他线程抢占)。队列节点执行完毕后虚拟节点出队，新的头结点变成虚拟节点。

5、出现中断或者失败情况使用cancelAcquire()方法取消排队，分为单个节点出队和节点链条出队(遍历判断waitState是否为取消情况)。

等待队列中头结点为空节点，即虚拟节点(哨兵节点)，用于占位，简化双向队列的操作。

# 读写锁

ReentrantReadWriteLock(读写锁)，资源能被**多个读线程或一个写线程访问**，但**不能读写同时访问**。适用于读操作多于写操作的情况。类似悲观锁策略，读写操作互斥。

1、读写互斥

2、读操作可以并发

3、写操作互斥

缺点：

1、写锁饥饿问题，当读操作远多于写操作时，会导致写操作过于滞后。

2、锁降级问题

**读写锁的可重入**：

线程获取读锁后可再次获取读锁；线程获取写锁后可再次获得读或者写锁

**读写锁的降级**：

1、如果一个线程持有了写锁，他又继续获取了读锁，释放掉写锁后就变成了读锁，这就是锁的降级。

2、读锁无法升级成写锁。

3、锁的降级是为了保证写操作数据的可见性，同一线程写操作后可以**马上**进行读操作，同时可以相较于一直使用写锁提高性能。

锁降级适用于**缓存设计**。

# StampedLock邮戳锁

邮戳锁是JDK8中对于读写锁的升级，增加了long类型的stamp代表锁的状态，0表示获取锁失败。

为了解决写锁饥饿问题，**允许读锁下获取写锁**，相较于公平锁牺牲吞吐量更优。类似乐观锁策略。

获取锁会返回一个邮戳，Stamp为0表示获取失败；释放锁需要一个邮戳，必须和获取锁返回的邮戳一致。

邮戳锁是**不可重入**的，如果一个线程已经持有了写锁，再去获取写锁就会造成死锁。

三种访问模式：

1、Reading（悲观读模式）：类似读写锁中的读锁

2、Writing（写模式）：类似读写锁中的写锁

3、Optimistic reading（乐观读模式）：无锁机制，类似乐观锁，支持读写并发，被修改时再升级为悲观读模式。

stampedLoc.validate(stamp)：返回true表示乐观读期间无写操作、false表示乐观读期间有写操作，判断有写操作时再手动升级成悲观读。

缺点：

1、不支持重入

2、不支持条件变量（Condition）

3、不能调用中断interrupt()方法
