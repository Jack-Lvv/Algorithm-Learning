[TOC]

# JVM

JVM 全称是Java Virtual Machine，中文译名 Java虚拟机。

JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java**字节码**文件。

## JVM的功能

1、解释和运行：对字节码文件中的指令， 实时的**解释**成机器码， 让计算机执行

2、内存管理： 自动为对象、方法等分配内存； 自动的垃圾回收机制， 回收不再使用的对象

3、即时编译： 对热点代码进行优化(解释后保存至内存, 使用时取出)， 提升执行效率

Java语言如果不做任何优化，性能不如C、C++等语言。Java需要**实时解释**，主要是为了支持**跨平台特性**。

 JVM提供了**即时编译**（Just-In-Time 简称JIT) 进行性能的优化，最终能达到接近C、C++语言的运行性能 甚至在特定场景下实现超越。

![JVM1](C:\Users\25798\OneDrive\Notes\image\JVM1.png)

![JVM2](C:\Users\25798\OneDrive\Notes\image\JVM2.png)

同时执行引擎还会调用一部分native标注的方法接口，来自于本地虚拟机中C/C++已经编译好的方法。

## 字节码文件

使用 **jclasslib**工具查看字节码文件。

**字节码文件组成**

1、基本信息：魔数、字节码文件对应的Java版本号 访问标识(public final等等) 父类和接口，数量统计信息

2、常量池：保存了字符串常量、类或接口名、字段名 主要在**字节码指令**中使用

3、字段：当前类或接口声明的**字段信息**

4、方法：当前类或接口声明的**方法信息转换为字节码指令**

5、属性：**类的属性**，比如源码的**文件名** **内部类的列表**等

6、接口：

**Magic魔数**

1、文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容。

2、 软件使用文件的头几个字节（**文件头**）去校验**文件的类型**，如果软件不支持该种类型就会出错。

3、Java字节码文件中，将**文件头**称为**magic魔数**。

**主副版本号** 

1、主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了 45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同 版本的标识，一般只需要关心主版本号。

2、版本号的作用主要是判断当前字节码的版本和运行时的JDK是否**兼容**。

**常量池**

字节码文件中**常量池**的作用：避免相同的内容重复定义，**节省空间**。

常量池中的数据都有一个**编号**，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。 

字节码指令中通过**编号引用**到常量池的过程称之为**符号引用**。

**String保存时保存一个String对象的常量以及内容的一个常量值，字段名同样可以用常量值来替代节省空间。**

## 字节码指令

```java
int i = 0;
i = i++;
// i的值为0，i++操作会直接在变量所在位置执行，不会在临时操作数栈中执行
// i++先加载i到临时操作数栈中，再加操作；++i则相反
```

同理i += 1和i++一样也是直接在变量所在位置执行，而不是**操作数栈**，**操作性能更快**

**阿里arthas**

Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。

官网：https://arthas.aliyun.com/doc/

**线上如何查看字节码文件？**

服务器上文件使用javap命令直接查看，也可以通过arthas的dump命令导 出字节码文件再查看本地文件。还可以使用jad命令反编译出源代码。

# 类的生命周期

类的生命周期描述了一个类加载、使用、卸载的整个过程

1、加载 2、连接 3、初始化 4、使用 5、卸载

## 加载

一、**加载**(Loading)阶段第一步是**类加载器**根据类的**全限定名**通过**不同的渠道**以**二进制流**的方式获取字节码信息。 程序员可以使用Java代码拓展的不同的渠道。

1、本地文件 2、动态代理生成(spring框架) 3、通过网络传输的类(已淘汰)

二、**类加载器**在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的**方法区**(c/c++)中。 生成一个**InstanceKlass对象**，保存类的所有信息，里边还包含实现特定功能比如**多态**的信息(虚方法表)。

三、同时，Java虚拟机还会在**堆**中生成将方法区中数据包装后的**java.lang.Class对象**。 作用是在Java代码中去**获取类的信息**以及**存储静态字段**的数据（JDK8及之后）。

 二三中的数据**相互关联**，对于开发者来说，只需要访问**堆中的Class对象**而不需要访问**方法区**中所有信息。 这样Java虚拟机就能很好地控制开发者访问数据的范围，同时提升安全性。

**查看内存中的对象** 

推荐使用 JDK自带的hsdb工具查看Java虚拟机内存信息。

工具位于JDK安装目录下lib文件夹中的sa-jdi.jar中。

启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB

## 连接

1、验证：验证内容是否满足《Java虚拟机规范》

2、准备：给静态变量**赋初值**

3、解析：将常量池中的**符号引用**替换成指向内存的**直接引用**

**验证**

具体详见《Java虚拟机规范》： 

1.文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过。

2.元信息验证，例如类必须有父类（super不能为空）。 

3.验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去。 

4.符号引用验证，例如是否访问了其他类中private的方法等。

**准备**

准备阶段为静态变量（static）分配内存并设置**初始值**。

final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

**解析**

解析阶段主要是将常量池中的符号引用替换为直接引用。

符号引用就是在字节码文件中使用编号来访问常量池中的内容。

直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。

## 初始化

初始化阶段会执行**静态代码块**中的代码，并为**静态变量赋值**。即**初始化阶段**会执行字节码文件中**clinit部分**的字节码指令。

静态代码块执行流程与java代码流程一致。即clinit方法中的执行顺序与Java中编写的**顺序是一致的**。

 以下几种方式会导致类的初始化：

1、访问一个类的静态变量或者静态方法，注意变量是**final修饰**的**并且等号右边是常量**不会触发初始化。

2、调用Class.forName(String className)。

3、new一个该类的对象时。

4、执行Main方法的当前类。

添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类

**clinit指令**在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行的。

1.无静态代码块且无静态变量赋值语句。

2.有静态变量的声明，但是没有赋值语句。

3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。

![JVM3](C:\Users\25798\OneDrive\Notes\image\JVM3.png)

直接访问父类的静态变量，不会触发子类的初始化。

子类的初始化clinit调用之前，会先调用父类的clinit初始化方法。

数组的创建不会导致数组中元素的类进行初始化。

# 类加载器

**类加载器（ClassLoader）**是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。 **类加载器只参与加载过程中的字节码获取并加载到内存这一部分**。获取二进制流的字节码文件。

**本地接口JNI是Java Native Interface的缩写**，允许Java调用其他语言编写的方法。 获取字节码文件生成方法区 对象 生成堆上 Class对象 在hotspot类加载器中，主要用于调用Java虚拟机中的方法，这些方法使用C++编写。

类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。

1、虚拟机底层实现 源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++

用于加载程序运行时的**基础类** 保证Java程序运行中基础类被正确地加载， 比如java.lang.String，确保其**可靠性**

2、JDK中默认提供或者自定义 JDK中默认提供了多种处理不同渠道的类加载器， 程序员也可以自己根据需求定制。继承自抽象类ClassLoader 所有Java中实现的类加载器都需要继承 ClassLoader这个抽象类。

![JVM4](C:\Users\25798\OneDrive\Notes\image\JVM4.png)

Arthas中类加载器的详细信息可以通过classloader命令查看

**启动类加载器**（BootstrapClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。默认加载Java安装目录/jre/lib下的类文件，比如rt.jar， tools.jar，resources.jar等。

通过启动类加载器去加载用户jar包： 

1、放入jre/lib下进行扩展 **不推荐**，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载 

2、使用参数进行扩展 **推荐**，使用-Xbootclasspath/a:jar包目录/jar包名 进行扩展

**java中无法获取启动类加载器，获取为null**

**扩展类加载器**和**应用程序类加载器**都是JDK中提供的、使用Java编写的类加载器。它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录 或者指定jar包将字节码文件加载到内存中。

![JVM5](C:\Users\25798\OneDrive\Notes\image\JVM5.png)

**扩展类加载器**（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录/jre/lib/ext下的类文件。

通过扩展类加载器去加载用户jar包

1、放入/jre/lib/ext下进行扩展 **不推荐**，尽可能不要去更改JDK安装目录中的内容

2、使用参数进行扩展 **推荐**，使用-Djava.ext.dirs=jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux) 追加上原始目录

Arthas中类加载器相关的功能，类加载器的加载路径可以通过classloader–c hash值查看

## 双亲委派机制

核心问题是要解决类到底由哪个加载器进行加载

1、**保证类加载的安全性** 通过双亲委派机制，让顶层的类加 载器去加载核心类，避免恶意代码 替换JDK中的核心类库，比如 java.lang.String，确保核心类库的完整性和安全性。

2、**避免重复加载** 双亲委派机制可以避免同一个类被多次加载，上层的类加载器如果加载过类，就会直接返回该类，避免重复加载。

双亲委派机制指的是：**自底向上查找是否加载过，再由顶向下进行加载**。

![JVM6](C:\Users\25798\OneDrive\Notes\image\JVM6.png)

每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级， 并不是继承关系。

应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空。启动类加载器使用C++编写，没有上级类加载器。

在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。**启动类加载器优先级最高。**

如果类加载的parent为null，则会提交给启动类加载器处理。

如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。

第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回。

![JVM7](C:\Users\25798\OneDrive\Notes\image\JVM7.png)

## 打破双亲委派机制

1、自定义类加载器

自定义类加载器并且重写 loadClass方法，就可以将双亲委派机制的代码去除

Tomcat通过这种方式实现应用之间类隔离

2、线程上下文类加载器

利用上下文类加载器加载类，比如 JDBC和JNDI等

3、 Osgi框架的类加载器

历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载

### Tomcat案例

一个**Tomcat程序**中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类， Tomcat要保证这两个类都能加载并且它们应该是不同的类。**每个应用使用自定义类加载器。**

如果不**打破双亲委派机制**，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的 MyServlet类就无法被加载了。

![JVM8](C:\Users\25798\OneDrive\Notes\image\JVM8.png)

```java
// 核心代码，外层加同步锁
if (parent != null) {
 c = parent.loadClass(name, false);
 } else {
 c = findBootstrapClassOrNull(name);
 }
if (c == null) 
c = findClass(name);
```

**通过自定义类加载器并且重写loadClass方法来打破双亲委派机制。**

**两个自定义类加载器加载相同限定名的类不会冲突**，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类。

defineClass类校验加载器不能加载java.开头的类。

**自定义加载器的默认父类加载器为：应用程序类加载器**

不需要打破双亲委派机制，自定义类加载器只需要重写findClass方法。

### JDBC案例

JDBC中使用了**DriverManager**来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。

DriverManager属于rt.jar是**启动类加载器**加载的。而用户jar包中的驱动需要由**应用程序类加载器**加载，这就违反了双亲委派机制。

DriverManager通过**JDK内置的SPI服务**来找到数据库驱动所在的位置并通过**应用程序类加载器**进行加载。

SPI服务通过驱动写好的名称来扫描包文件来获取驱动。

SPI通过当前线程保存的上下文类加载器来拿到应用程序类加载器。

也可以说没有打破双亲委派机制 JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制。

**OSGi模块化**

历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的 功能。

热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。

**现在可以通过阿里arthas进行不停机热部署**

![JVM9](C:\Users\25798\OneDrive\Notes\image\JVM9.png)

**注意事项：** 

1、程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。 

2、使用retransform不能添加方法或者字段，也不能更新正在执行中的方法。

## JDK9的变化

由于JDK9引入了**module**的概念，类加载器在设计上发生了很多变化。 

1、**启动类加载器**使用**Java编写**，位于jdk.internal.loader.ClassLoaders类中。

Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。 

启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。

2、**扩展类加载器**被替换成了**平台类加载器**（Platform Class Loader）。

平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了 BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。

平台类加载器的存在更多的是 为了与老版本的设计方案兼容，自身没有特殊的逻辑。

# 内存区域

 Java虚拟机在运行Java程序过程中管理的内存区域，称之为**运行时数据区**。

![JVM10](C:\Users\25798\OneDrive\Notes\image\JVM10.png)

**内存溢出**：指总内存占用超过了系统规定可以被占用的内存大小。

**内存泄漏**：指以不会再被使用的对象或者变量的内存占用没有被回收。

## 程序计数器

**程序计数器**（Program Counter Register）也叫**PC寄存器**，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。

在**加载阶段**，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的**偏移量**转换成**内存地址**。每一条字节码指令都会拥有一个内存地址。

在**代码执行过程**中，**程序计数器**会记录**下一行字节码指令的地址**。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。

 在**多线程执行**情况下，Java虚拟机需要通过**程序计数器记录CPU切换前**解释执行到那一句指令并继续解释运行。

因为每个线程只存储一个固定长度的内存地址，**程序计数器是不会发生内存溢出**的。

## 栈

Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，**先 进后出**（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。

异常抛出就是这个栈的内容。

**Java虚拟机栈**随着**线程的创建而创建**，而**回收则会在线程的销毁**时进行。由于方法可能会在不同线程中执行，**每个线程都会包含一个自己的虚拟机栈**。

1、局部变量表

局部变量表的作用是在运行过程中存放所有的**局部变量**

2、操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来**存放临时数据**的一块区域

3、帧数据

帧数据主要包含**动态链接、方法出口、异常表的引用**

### 局部变量表

栈帧中的**局部变量表**是一个**数组**，数组中每一个位置称之为**槽**(slot) ，**long和double**类型占用**两个槽**，其他类型占用**一个槽**。

实例方法中的**序号为0**的位置存放的是**this**，指的是**当前调用方法的对象**，运行时会在内存中存放实例对象的**地址**。

**方法参数**也会保存在**局部变量表**中，其**顺序与方法中参数定义的顺序一致**。

局部变量表保存的内容有：**实例方法的this对象，方法的参数，方法体中声明的局部变量。**

![JVM11](C:\Users\25798\OneDrive\Notes\image\JVM11.png)

### 操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来**存放中间数据**的一块区域。他是一种栈式的数据结构，如 果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。

在**编译期**就可以确定**操作数栈的最大深度**，从而在执行时正确的分配内存大小。

### 帧数据

当前类的字节码指令**引用**了其他类的属性或者方法时，需要将**符号引用（编号）**转换成对应的运行时**常量池中的内存地址**。**动态链接**就保存了编号到运行时常量池的内存地址的**映射关系**。

**方法出口**指的是**方法在正确或者异常结束**时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要**存储此方法出口的地址**。

**异常表**存放的是**代码中异常的处理信息**，包含了**异常捕获的生效范围**以及异常发生后**跳转到的字节码指令位置**。

### 栈的大小

Java虚拟机栈 –默认大小：如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构，例如**1M**。

要**修改Java虚拟机栈的大小**，可以使用虚拟机参数 -Xss。

语法：-Xss栈大小

单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

**HotSpot JVM**对栈大小的最大值和最小值有要求：

Windows（64位）下的**JDK8**测试**最小值**为**180k**，**最大值**为**1024m**。

**一般情况下**，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数 可以**手动指定为-Xss256k节省内存**。

**Java虚拟机栈**存储了**Java方法调用**时的栈帧，而**本地方法栈**存储的是**native本地方法**的栈帧。

在Hotspot虚拟机中，**Java虚拟机栈**和**本地方法栈**实现上使用了**同一个栈空间**。

## 堆

一般Java程序中**堆内存**是空间**最大的一块内存区域**。**创建出来的对象**都存在于堆上。

栈上的局部变量表中，可以存放堆上**对象的引用**。静态变量也可以存放堆对象的引用，通过**静态变量就可以实现对象在线程之间共享**。

堆空间有三个需要关注的值，used total max。

**used**指的是当前**已使用的堆内存**，**total**是java虚拟机**已经分配的可用堆内存**，**max**是java虚拟机可以分配的**最大堆内存**。

随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆。total最多只能与max相等。

如果不设置任何的虚拟机参数，**max默认是系统内存的1/4**，**total默认是系统内存的1/64**。在实际应用中一般都需要设置 total和max的值。

要**修改堆的大小**，可以使用虚拟机参数 –Xmx（max最大值）和-Xms(初始的total)。

语法：-Xmx值 -Xms值 

单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

限制：Xmx必须大于 2 MB，Xms必须大于1MB

Java服务端程序开发时，建议**将-Xmx和-Xms设置为相同的值**，这样在程序启动之后可使用的总内存就是最大内存，而**无需向java虚拟机再次申请**，**减少了申请并分配内存时间上的开销**，同时也**不会出现内存过剩之后堆收缩的情况**。

## 方法区

方法区是存放**基础信息**的位置，**线程共享**，主要包含三部分内容：

1、**类的元信息** 保存了所有类的基本信息

2、**运行时常量池** 保存了字节码文件中的常量池内容

3、**字符串常量池** 保存了字符串常量

方法区是用来存储每个类的基本信息（**元信息**），一般称之为**InstanceKlass对象**。在类的**加载阶段**完成。

字节码文件中通过**编号查表**的方式找到常量，这种常量池称为**静态常量池**。当常量池加载到内存中之后，可以通过**内存地址**快速的定位到常量池中的内容，这种常量池称为**运行时常量池**。

**JDK7及之前的版本**将**方法区**存放在**堆区域中的永久代空间**，堆的大小由虚拟机参数来控制。

**JDK8及之后的版本**将**方法区**存放在**元空间**中，元空间位于**操作系统维护的直接内存**中，默认情况下只要不超过操作系统承受的上限，可以一直分配。

**使用-XX:MaxMetaspaceSize=值将元空间最大大小进行限制。**

**字符串常量池**存储在代码中定义的**常量字符串**内容。

![JVM12](C:\Users\25798\OneDrive\Notes\image\JVM12.png)

![JVM13](C:\Users\25798\OneDrive\Notes\image\JVM13.png)

```java
String a = "1";
String b = "2";
String c = "12";
String d1 = a + b;
// 底层调用了SpringBuilder，d1存放在了堆中，与c不相同
String d2 = "1" + "2";
// 底层直接将加号去掉视做字符串常量，所以d2与c相同
```

**String.intern()**方法是可以手动将字符串放入字符串常量池中，java在JVM启动时就会加入常量池, 分别在JDK6 JDK8下执行代码，JDK6 中结果是false false ，JDK8中是true false

JDK7及以后intern方法会将堆的引用存入常量池，不会复制一份到常量池中。

![JVM14](C:\Users\25798\OneDrive\Notes\image\JVM14.png)

JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代。

JDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代。

## 直接内存

直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。 

在 JDK 1.4 中引入了 **NIO 机制**，使用了直接内存，主要为了解决以下两个问题:

1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。

2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。 现在直接放入直接内存即可，同时**Java堆上维护直接内存的引用**，**减少了数据复制的开销**。写文件也是类似的思路。

要**创建直接内存上的数据**，可以使用**ByteBuffer**。

语法： ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);

注意事项： arthas的memory命令可以查看直接内存大小，属性名direct。

需要手动调整**直接内存的大小**，可以使用**-XX:MaxDirectMemorySize=大小**

![JVM15](C:\Users\25798\OneDrive\Notes\image\JVM15.png)

![JVM16](C:\Users\25798\OneDrive\Notes\image\JVM16.png)

![JVM17](C:\Users\25798\OneDrive\Notes\image\JVM17.png)

# 垃圾回收

 在C/C++这类**没有自动垃圾回收机制**的语言中，一个对象如果不再使用，需要**手动释放**，否则就会出现内存泄漏。我们称这种释放对象的过程为**垃圾回收**，而需要程序员编写代码进行回收的方式为**手动回收**。

**内存泄漏**指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致**内存溢出**。

 **Java**中为了简化对象的释放，引入了**自动的垃圾回收**（Garbage Collection简称**GC**）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对**堆**上的内存进行回收。其他 很多现代语言比如C#、Python、Go都拥有自己的**垃圾回收器**。

![JVM18](C:\Users\25798\OneDrive\Notes\image\JVM18.png)

**线程不共享**的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的**栈帧**在执行完方法之后就会**自动弹出栈并释放掉对应的内存**。不需要垃圾回收器来回收。

## 方法区的回收

判定一个类可以被卸载。需要同时满足下面三个条件： 

1、此类**所有实例对象**都**已经被回收**，在堆中不存在任何该类的**实例对象以及子类对象**。 

2、加载该**类的类加载器**已经**被回收**。 

3、该类对应的 java.lang.Class **对象没有在任何地方被引用**。

**手动触发垃圾回收**，可以调用**System.gc()**方法。

语法：System.gc()

注意事项： 调用System.gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机**发送一个垃圾回收的请求**，具体是否需要执行垃圾回收**Java虚拟机会自行判断**。

JSP等技术会通过回收类加载器去回收方法区中的类

## 堆的回收

Java中的对象是否能被回收，是根据**对象是否被引用**来决定的。如果对象被引用了，说明该对象还 在使用，不允许被回收。判断堆上的对象没有被引用，常见的有两种判断方法：**引用计数法**和**可达性分析法**。

### 引用计数法

引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

引用计数法的优点是实现简单，**C++中的智能指针**就采用了引用计数法，但是它也存在缺点，主要有两点：

1.每次引用和取消引用都需要维护计数器，**对系统性能会有一定的影响** 

2.存在循环引用问题，所谓**循环引用**就是当A引用B，B同时引用A时会出现**对象无法回收**的问题。

 **如果想要查看垃圾回收的信息，可以使用-verbose:gc参数。**

### 可达性分析算法

Java使用的是**可达性分析算法**来判断对象是否可以被回收。可达性分析将对象分为两类：**垃圾回收的根对象**（GC  Root）和**普通对象**，对象与对象之间存在引用关系。

可达性分析算法指的是如果从某个**GC Root对象是可达的**，**对象就不可被回收**。

**GC Root对象：**

1、线程Thread对象。

2、系统类加载器加载的java.lang.Class对象。

3、监视器对象，用来**保存同步锁synchronized关键字持有的对象**。

4、本地方法调用时使用的全局对象。

## 对象引用

可达性算法中描述的**对象引用**，一般指的是**强引用**。

1、强引用

2、软引用

3、弱引用

4、虚引用

5、终结器引用

### 软引用

软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序**内存不足**时，就**会将软引用中的数据进行回收**。 

在JDK 1.2版之后提供了**SoftReference类来实现软引用**，软引用常用于**缓存**中。

同时SoftReference提供了一套队列机制： 

1、软引用创建时，通过**构造器**传入**引用队列**

2、在软引用中包含的**对象被回收**时，该软引用对象会被**放入引用队列** 

3、通过**代码遍历引用队列**，将SoftReference**本身的强引用删除**

### 弱引用

弱引用的**整体机制和软引用基本一致**，区别在于弱引用包含的对象在垃圾回收时，**不管内存够不够都会直接被回收**。 

在JDK 1.2版之后提供了**WeakReference类**来实现弱引用，弱引用主要在**ThreadLocal**中使用。 弱引用对象本身也可以使用**引用队列进行回收**。

### 虚引用和终结器引用

这两种引用在**常规开发**中是**不会使用**的。

1、**虚引用**也叫幽灵引用/幻影引用，**不能通过虚引用对象获取到包含的对象**，必须和引用队列联合使用。虚引用唯一的用途是当对象**被垃圾回收器回收时可以接收到对应的通知**，Java中使用**PhantomReference**实现了虚引用。**直接内存**中为了**及时知道直接内存对象不再使用**，从而回收内存，**使用了虚引用来实现**。

2、**终结器引用**指的是在**对象需要被回收**时，终结器引用会关联对象并放置在Finalizer类中的**引用队列**中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后**执行对象的finalize方法**，在对象**第二次被回收**时，该**对象才真正的被回收**。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。

## 垃圾回收算法

垃圾回收要做的有两件事： 

1、找到内存中存活的对象 

2、释放不再存活对象的内存，使得程序能再次利用这部分空间

![JVM19](C:\Users\25798\OneDrive\Notes\image\JVM19.png)

Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要**停止所有的用户线程**。这个过程被称之为Stop The World简称**STW**，如果S**TW时间过长则会影响用户的使用**。

### 评价标准

1、**吞吐量**

吞吐量指的是 CPU 用于**执行用户代码的时间**与 **CPU 总执行时间的比值**，即吞吐量 = 执行用户代码时间 / （执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。

2、**最大暂停时间**

最大暂停时间指的是所有在**垃圾回收过程中的STW时间最大值**。比如如下的图中，黄色部分的STW就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。

3、**堆使用效率**

不同垃圾回收算法，对堆内存的使用方式是不同的。比如**标记清除算法**，可以使用**完整的堆内存**。而**复制算法**会将**堆内存一分为二**，**每次只能使用一半内存**。从堆使用效率上来说，标记清除算法要优于复制算法。

一般来说，**堆内存越大**，**最大暂停时间就越长**。想要**减少最大暂停时间**，就会**降低吞吐量**。 不同的垃圾回收算法，适用于不同的场景。

### 标记清除算法

标记清除算法的核心思想分为两个阶段： 

1.标记阶段，将**所有存活的对象进行标记**。Java中使用**可达性分析算法**，从GC Root开始通过**引用链遍历出所有存活对象**。 

2.清除阶段，从内存中**删除没有被标记**也就是非存活对象。

**优点**：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。 

**缺点**：

1、**碎片化问题** 由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。

2、**分配速度慢** 由于内存碎片的存在，需要**维护一个空闲链表**，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。

### 复制算法

1、准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。 

2、在垃圾回收GC阶段，将From中存活对象复制到To空间。 

3、将两块空间的From和To名字互换。

完整的复制算法的例子： 

1、将堆内存分割成两块From空间To空间，对象分配阶段，创建对象。 

2、GC阶段开始，将GC Root搬运到To空间 

3、将GC Root关联的对象，搬运到To空间 

4、清理From空间，并把名称互换

**优点：**

1、**吞吐量高** 复制算法只需要遍历一次存活对象 复制到To空间即可，比标记-整理 算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法， 因为标记清除算法不需要进行对象的移动

2、**不会发生碎片化** 复制算法在复制之后就会将对象按顺序放优点缺点入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

**缺点：**

**内存使用效率低** 每次只能让一半的内存空间来为创建对象使用

### 标记整理算法

标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生**内存碎片问题**的一种**解决方案**。 

核心思想分为两个阶段： 

1、**标记阶段**，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出 所有存活对象。 

2、**整理阶段**，将存活对象移动到堆的一端。清理掉存活对象的内存空间。

**优点**：

1、**内存使用效率高** 整个堆内存都可以使用，不会像复制算法只能使用半个堆内存

2、**不会发生碎片化** 在整理阶段可以将对象往内存的一侧进行优点缺点移动，剩下的空间都是可以分配对象的有效空间

**缺点**：

**整理阶段的效率不高** 整理算法有很多种，比如Lisp2整 理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能

### 分代垃圾回收算法

现代优秀的垃圾回收算法，会将上述描述的**垃圾回收算法组合进行使用**，其中**应用最广**的就是分代垃圾回收算法(Generational GC)。 

分代垃圾回收将整个**内存区域**划分为**年轻代**和**老年代**：

![JVM20](C:\Users\25798\OneDrive\Notes\image\JVM20.png)

Young区(存活时间比较短的对象)：Eden区、From区、To区

Old区(存活时间比较长的对象)：

1、分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。

2、随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为 Minor GC或者Young GC。 Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。

3、接下来，To区和From区互换。当eden区满时再往里放入对象，依然会发生Minor GC。 此时会回收eden区和From区中的对象，并把eden和from区中剩余的对象放入to区。 注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。

4、如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。

5、当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发**Full GC**，Full GC会对**整个堆进行垃圾回收**。 如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出**Out Of Memory**异常。

![JVM21](C:\Users\25798\OneDrive\Notes\image\JVM21.png)

为什么分代GC算法要把堆分成年轻代和老年代？

1、系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。

2、老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。

3、在虚拟机的默认设置中，新生代大小要小于老年代的大小。

**同时：**

1、可以通过调整年轻代和老年代的**比例**来适应不同类型的应用程序，**提高内存的利用率和性能**。

2、新生代和老年代使用不同的垃圾回收算法，**新生代一般选择复制算法**，**老年代可以选择标记-清除和标记-整理算法**，由程序员来选择**灵活度较高**。

3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full  gc),**STW时间就会减少**。

## 垃圾回收器

![JVM22](C:\Users\25798\OneDrive\Notes\image\JVM22.png)

### Serial和SerialOld垃圾回收器

Serial是一种**单线程串行**回收年轻代的垃圾回收器。

**年轻代、复制算法**

**优点** ：**单CPU处理器**下吞吐量非常出色

**缺点**：**多CPU下吞吐量**不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**： Java编写的客户端程序或者**硬件配置有限**的场景



**SerialOld**是Serial垃圾回收器的老年代版本，采用**单线程串行回收**

**-XX:+UseSerialGC** 新生代、老年代都使用串行回收器。

**老年代、标记-整理算法**

**优缺点同上**

**适用场景** 与**Serial垃圾回收器搭配使用**， 或者在CMS特殊情况下使用

### ParNew垃圾回收器

ParNew垃圾回收器本质上是对**Serial在多 CPU下的优化**，使用**多线程**进行垃圾回收

**-XX:+UseParNewGC** 新生代使用ParNew回收器， 老年代使用串行回收器

**年轻代、复制算法**

**优点** 多CPU处理器下停顿时间较短

**缺点** 吞吐量和停顿时间不如G1， 所以在JDK9之后不建议使用

**适用场景** JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用

### CMS垃圾回收器

CMS(Concurrent Mark Sweep)垃圾回收器关注的是**系统的暂停时间**， **允许用户线程和垃圾回收线程**在某些步骤中**同时执行**，**减少**了用户线程的**等待时间**。

参数：XX:+UseConcMarkSweepGC

**老年代、标记清除算法**

**优点** 系统由于垃圾回收出现的停顿时间较短，用户体验好

**适用场景** 大型的互联网系统中用户请求**数据量大**、**频率高**的场景比如订单接口、商品接口等

**CMS执行步骤**： 

1、**初始标记**，用极短的时间标记出GCRoots能直接关联到的对象。

2、**并发标记**,   标记所有的对象，用户线程不需要暂停。

3、**重新标记**，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。

4、**并发清理**，清理死亡的对象，用户线程不需要暂停。

**缺点**： 

1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。 这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之 后再整理。 

2、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。 

3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。

**线程资源争抢问题**

在CMS中并发阶段运行时的线程数可以通过-XX:ConcGCThreads参数设置，默认值为0，由系统计算得出。

计算公式为(-XX:ParallelGCThreads定义的线程数 + 3) / 4， ParallelGCThreads是STW停顿之后的 并行线程数。

**ParallelGCThreads**是由处理器核数决定的

1、当cpu核数小于8时，ParallelGCThreads = CPU核数 

2、否则 ParallelGCThreads = 8 + (CPU核数– 8 )*5/8 

由于CPU的**核心数有限**，就会影响用户线程执行的性能。

### Parallel Scavenge垃圾回收器

Parallel Scavenge是JDK8默认的年轻代垃圾回收器， **多线程并行回收**，关注的是系统的**吞吐量**。具备**自动调整堆内存大小**的特点。

**年轻代、复制算法**

**优点** 用户线程**吞吐量高**，而且**手动可控**。 为了提高吞吐量，虚拟机会**动态调整堆的参数**

**缺点 **不能保证单次的停顿时间

**适用场景** 后台任务，不需要与用户交互，并且容易产生大量的对象 比如：大数据的处理，大文件导出

Parallel Scavenge允许**手动设置**最大暂停时间和吞吐量。 Oracle官方建议在使用这个组合时，**不要设置堆内存的最大值**，垃圾回收器会根据最大暂停时间和吞吐量**自动调整内存大小**。

**最大暂停时间**-XX:MaxGCPauseMillis=n 设置每次垃圾回收时的最大停顿毫秒数

**吞吐量**-XX:GCTimeRatio=n 设置吞吐量为n（用户线 程执行时间 = n/n + 1）

**自动调整内存大小**-XX:+UseAdaptiveSizePolicy设置 可以让垃圾回收器根据吞吐量和最 大停顿的毫秒数自动调整内存大小

### Parallel Old垃圾回收器

Parallel Old是为Parallel Scavenge收集器设计的老年代版本，利用**多线程并发收集**。

参数：-XX:+UseParallelGC 或-XX:+UseParallelOldGC可以使用 Parallel Scavenge + Parallel Old这种组合。

**老年代、标记-整理算法**

**优点** 并发收集，在多核CPU下 效率较高

**缺点** 暂停时间会比较长

**适用场景** 与Parallel Scavenge配套使用

### G1垃圾回收器

JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。 

**Parallel Scavenge**关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。 

**CMS**关注暂停时间，但是吞吐量方面会下降。 

而G1设计目标就是将上述**两种垃圾回收器的优点融合**： 

1.支持巨大的堆空间回收，并有较高的吞吐量。 

2.支持多CPU并行垃圾回收。 

3.允许用户设置最大暂停时间。

**内存结构**

G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。

分为Eden、Survivor、 Old区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其 中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。

**G1垃圾回收**有两种方式：

1、年轻代回收（Young GC）

回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数-XX:MaxGCPauseMillis=n（默认200） 设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。

2、混合回收（Mixed GC）

混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize  Marking）、并发清理（cleanup）

G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage  first）名称的由来。最后清理阶段使用复制算法，不会产生内存碎片。

**执行流程** 

1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行 Young GC。 

2、标记出Eden和Survivor区域中的存活对象， 

3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。

G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。

4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。 

5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。

6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是 4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。

7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时 （-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。

![JVM24](C:\Users\25798\OneDrive\Notes\image\JVM24.png)

**注意**：如果清理过程中发现没有足够的空Region存放转移的对象，会出现**Full GC**。单线程执行标记-整理算法， 此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。

参数1： -XX:+UseG1GC  打开G1的开关， JDK9之后默认不需要打开 

参数2：-XX:MaxGCPauseMillis=毫秒值  最大暂停的时间

**优点** 对比较大的堆如超过6G的堆回收 时，延迟可控 不会产生内存碎片 并发标记的SATB算法效率高

**缺点** JDK8之前还不够成熟

**适用场景** JDK8最新版本、JDK9之后建议默认使用

![JVM23](C:\Users\25798\OneDrive\Notes\image\JVM23.png)

