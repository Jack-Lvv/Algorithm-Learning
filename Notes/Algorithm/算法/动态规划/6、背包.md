# 背包问题

[TOC]

## 0-1背包

### 语法

### 原理

每个货物只可以选择1次

dp[i] [j]：1 - i 物品自由选择，容量不超过j的情况下的最大价值

```java
dp[i][j] = dp[i - 1][j];
if(matrix[i][0] <= j) {
    dp[i][j] = Math.max(dp[i][j], 
    dp[i - 1][j - matrix[i][0]] + matrix[i][1]);
}
```

**注意**：复杂度超过的题目不能用背包解决，例如**前k小子序列和**

### 题目



## 有依赖的背包

### 语法

### 原理

物品分为两大类：主件和附件

主件购买没有限制，钱够就可以；附件购买有限制，该附件所归属的主件先购买，才能购买这个附件

和0-1背包类似，多考虑几种展开情况：

1、不要主件和附件

2、只要主件

3、要主件和附件

boolean[] king：表示是否为主件

int [ ] [ ] follows：表示主件对应的附件

int[] fans：表示主件对应的附件数

dp展开过程中只关心主件，需要记录上一件主件的下标，进行展开

### 题目



## 分组背包

### 语法

### 原理

多个物品分组，每组只能取1件。

每一组的物品都可能性展开就可以了。

用start和end双指针确定一组的位置进行遍历

for (组的循环)

​	双指针求组的起始位置

​	for (背包容量循环)

​		for (一个组内物品循环) 求出利润的max dp

### 题目



## 完全背包

### 语法

### 原理

每种商品可以选取无限次。

与0-1背包类似：

```java
dp[i][j] = Math.max(dp[i-1][j],
                   dp[i][j-mx[i][1]]);
```

### 题目



## 多重背包

### 语法

### 原理

与完全背包不同之处，每一种物品给定数量的限制，不是无限

进行可能性展开，枚举所有数量的情况

**多重背包的枚举优化**：二进制分组优化（最常用）、单调队列优化（复杂度最好，理解稍难）

**二进制分组优化：**

例如将50限制的枚举，转化为1、2、4、8、16、19的 **0-1背包问题**

二进制分组后可以组合出所有的枚举情况

### 题目



## 混合背包

### 语法

### 原理

多种背包模型的组合与转化

**完全背包和多重背包组合**：完全背包可以转化为多重背包，多重背包通过二进制分组转换为0-1背包

其他混合背包：进行i的限制分类讨论，多重背包使用滑动窗口优化或者单调队列优化。

### 题目



## 三维双费用背包

### 语法

```java
int[][][] dp = new int[size + 1][m + 1][n + 1];
    for (int i = 1; i <= size; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                dp[i][j][k] = dp[i - 1][j][k];
                if (j >= matriax[i][0] && k >= matriax[i][1]) {
                    dp[i][j][k] = Math.max(dp[i][j][k], 
                     dp[i - 1][j - matriax[i][0]][k - matriax[i][1]] + 1);
                }
            }
        }
    }
    return dp[size][m][n];
```



### 原理

即题目给出费用有两个限制

### 题目
