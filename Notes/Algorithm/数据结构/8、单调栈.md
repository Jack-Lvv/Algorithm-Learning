# 单调栈

[TOC]

## 语法

```java
public class Solution {
    public int[][] foundMonotoneStack(int[] nums) {
        int n = nums.length;
        int[] stack = new int[n];
        int[][] ans = new int[n][2];
        int top = -1;
        for (int i = 0; i < n; i++) {
            while (top >= 0 && nums[i] <= nums[stack[top]]) {
                ans[stack[top]][1] = i;
                ans[stack[top]][0] = top == 0 ? -1 : stack[top-1];
                top--;
            }
            stack[++top] = i;
        }
        while (top >= 0) {
            ans[stack[top]][1] = -1;
            ans[stack[top]][0] = top == 0 ? -1 : stack[top-1];
            top--;
        }
        for (int i = n-1; i >= 0; i--) {
            if (ans[i][1] != -1 && nums[ans[i][1]] == nums[i]) {
                ans[i][1] = ans[ans[i][1]][1];
            }
        }
        return ans;
    }
}
```



## 原理

单调栈**最经典的用法**是解决如下问题：

**每个位置都求**：

0）当前位置的 左侧比当前位置的数字小（大），且距离**最近的位置** 在哪

1）当前位置的 右侧比当前位置的数字小（大），且距离**最近的位置** 在哪



1，数组无重复值的情况

创建栈，栈中存放数组的下标

按大压小（小压大）的原则进栈，违反原则就弹出、结算位置的结果，弹出后栈顶为左侧数据，令其违反原则的数据为右侧

清算剩余栈中数据（右侧数据不存在）

2，数组有重复值的情况

相等的情况同上，但右侧的数据是错误的，需要最后再修正。

从后往前修正相等的右侧数据。



用单调栈的方式可以做到：求解过程中，单调栈所有调整的总代价为O(n)，单次操作的均摊代价为O(1)



单调栈还可以 **维持求解答案的可能性**

1）单调栈里的所有对象按照 规定好的**单调性**来组织

2）当某个对象进入单调栈时，

  会从 栈顶开始 依次淘汰单调栈里 对后续求解答案没有帮助 的对象

3）每个对象从栈顶弹出的时 结算当前对象参与的答案，随后这个对象 不再参与后续求解答案的过程

4）其实是 先有对题目的分析！进而发现单调性，然后利用 单调栈的特征 去实现



**注意**：

单调栈可以和很多技巧交叉使用

比如：动态规划+单调栈优化

## 题目