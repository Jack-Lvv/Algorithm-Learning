# 位运算

[TOC]

## 语法

0b数字前缀表示二进制c = 0b1001110，0x表示十六进制d = 0x4e;

二进制求相反数：

```java
e = ~a + 1;
```

按位取反：~

按位取或：|

按位取并：&

按位异或：^

左移：<<    相当于乘2（非负数）

右移：>>    相当于除2（非负数）  空位用符号位填充，即不改变正负性

逻辑右移： >>>    右移，但是空位一律用0补位

## 原理

### 二进制

补码：表示负数用二进制正数按位取反，然后加1。

补码意义：使得正数负数加法逻辑相同（自己确保不会溢出，计算机不会检查）

int 类型数字为32位，long 类型为64位

### 位运算

左移右移注意位数是否溢出：例如1(int) << 48 已溢出，应为(1L <<  48)

加法：a + b = a ^ b(不进位相加) + (a & b<<1)(进位信息)   重复进行，直到a&b=0

减法：a - b = a + (~b+1)

乘法：a * b 每次b>>1末尾不为0，则累加一次a<<1

除法：a / b 从高位到低位判断含不含2^位数，即是否大于

### 异或  （不进位相加）

满足交换律和结合律

0^n = n        n^n = 0

x^y = z, 则x= y^z

```java
//交换a,b两个数(前提必须两个数有各自不同的数据空间)
a = a^b;
b = a^b;
a = a^b;
```

判断正负：n>>> 31,得其符号位

找数组在另一个数组中缺少的一个数字

返回出现唯一 一个奇数次的数字

取出二进制数中最右侧的1：n & (~n + 1)

进阶：找出两个出现奇数次的数字

找出唯一 一个次数出现少于m的数，其他数都是m次

0到n所有数异或的值：符合规律，周期为4

## 题目

打印int类型数字的二进制：

```java
public static void printBinary(int num) {
		for (int i = 31; i >= 0; i--) {
			// 下面这句写法，可以改成 :
			// System.out.print((a & (1 << i)) != 0 ? "1" : "0");
			// 但不可以改成 :
			// System.out.print((a & (1 << i)) == 1 ? "1" : "0");
			// 因为a如果第i位有1，那么(a & (1 << i))是2的i次方，而不一定是1
			// 比如，a = 0010011
			// a的第0位是1，第1位是1，第4位是1
			// (a & (1<<4)) == 16（不是1），说明a的第4位是1状态
			System.out.print((num & (1 << i)) == 0 ? "0" : "1");
		}
		System.out.println();
	}
```

判断一个数是不是2的幂（是不是3的幂）

返回大于等于n的最小的2的幂

求范围内[left, right]所有数&的值

二进制数逆序

返回一个数二进制中1的个数
